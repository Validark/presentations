<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="utf-8">
	<title>Step by Step Tokenization in Zig</title>

	<link rel="stylesheet" type="text/css" href="./fonts/Iosevka/Iosevka.css">

	<style>
		[hidden] {
		  display: none;
		}

		g.slide:not([hidden]) > .h2:first-child,
		g.slide:not([hidden]) > [click=""]:not([hidden]),
		g.slide:not([hidden]) > [click=""]:not([hidden]) text:not(.highlighted),
		g.slide:not([hidden]) > [click=""]:not([hidden]) tspan:not(.highlighted),
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) text:not(.highlighted),
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) tspan:not(.highlighted)
		{
			animation: unhide 1s cubic-bezier(0, 0, 0.53, 1) 0s 1 forwards;
		}


		g.slide:not([hidden]) > [click=""]:not([hidden]) text.highlighted,
		g.slide:not([hidden]) > [click=""]:not([hidden]) tspan.highlighted,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) text.highlighted,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) tspan.highlighted
		{
			animation: unhide-highlighted 1s cubic-bezier(0, 0, 0.53, 1) 0s 1 forwards;
		}

		g.slide:not([hidden]) {
			animation: unhide-slide 1s ease 0s 1 forwards;
		}

		.unhide-slide {
			animation: unhide-slide 1s ease 0s 1 forwards;
		}

		.hide-slide {
			animation: hide-slide 1s ease 0s 1 forwards;
		}

		@keyframes unhide {
			0%   { transform: translateY(-60px); stroke: rgba(255, 255, 255, 1); stroke-width: 5px; }
			100% { transform: translateY(0); stroke: rgba(255, 255, 255, 0) }
		}

		@keyframes unhide-highlighted {
			0%   { transform: translateY(-60px); stroke: rgba(255, 255, 255, 1); stroke-width: 5px; }
			100% { transform: translateY(0); stroke: rgba(255, 0, 0, 1); stroke-width: inherit; }
		}

		@keyframes unhide-slide {
			from   { transform: translateY(-60px); }
		}

		@keyframes hide-slide {
			to   { transform: translateY(-60px); opacity: 0; }
		}

		g.slide#title {
			animation: unhide-svg 10s cubic-bezier(0, 1, 0, 1) 0s 1 forwards !important;
		}

		@keyframes unhide-svg {
			0%   { transform: scale(0) translate(1100px, 1600px); }
			100% { transform: scale(1) translate(0, 0); }
		}

		@font-face {
			font-family: 'Press Start 2P';
			src: url('./fonts/Press_Start_2P/PressStart2P-Regular.ttf') format('truetype');
			font-weight: 400;
			font-style: normal;
			font-display: block;
		}

		@font-face {
			font-family: 'Ysabeau Office';
			src: url('./fonts/Ysabeau_Office/static/YsabeauOffice-Regular.ttf') format('truetype');
			font-weight: 400;
			font-style: normal;
			font-display: block;
		}

		@font-face {
			font-family: 'Ysabeau Office';
			src: url('./fonts/Ysabeau_Office/static/YsabeauOffice-Medium.ttf') format('truetype');
			font-weight: 500;
			font-style: normal;
			font-display: block;
		}

		* {
			padding: 0;
			margin: 0;
			box-sizing: border-box;
		}

		html, body, #container, #overlay {
			height: 100%;
			width: 100%;
			font-size: 12pt
		}

		.h1, .h2, .h3, .h4 {
			font-family: "Press Start 2P";
			color: hsl(265, 89%, 78%);
			text-align: center;
			line-height: 1.25;
		}

		.h2, .h3, .h4 {
			fill: hsl(265, 89%, 78%);
		}

		h1, .h1 {
			font-size: 8rem;
		}

		h2, .h2 {
			font-size: 4.25rem;
		}

		.h3 {
			font-size: 2.75rem;
		}

		.h4 {
			font-size: 2rem;
		}

		#container, #overlay {
			height: 100%;
			width: 100%;
			position: absolute;
			background-color: #000
			/* animation: container-background 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0s 1 forwards; */
		}

		#overlay {
			position: fixed;
			background: none;
		}

		@keyframes container-background {
			0% { background-color: hsl(231, 15%, 18%) }
			100%   { background-color: #000 }
		}

		/* .slide {
			padding-top: 1in;
			padding-bottom: 1in;
			padding-left: 1in;
			padding-right: 1in;
		} */

		ol, ul, p, pre {
			font-size: 2.5rem;
			color: #F8F8F2;
			font-family: "Press Start 2P";
			line-height: 1.25;
			letter-spacing: -2px;
		}

		ol, ul, p {
			margin-left: 4rem;
		}

		.slide > p,
		.slide > ul,
		.slide > ol {
			margin-top: 1rem;
		}

		ol ol {
			list-style-type: lower-alpha;
		}

		a {
			color:aqua
		}
	</style>

	<script>
	    const global_animations = [];
		const global_scrolls = [];
		const state_transitions = new Map();
		const post_processes = [];
	</script>
</head>

<body style="padding-bottom: 0px; padding-right: 0px">

<svg id="container" viewBox="0 0 1920 1080" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<g class="slide" id="title">
		<text class="h1 title-line" x="965" y="325" fill="#F7A41D" text-anchor="middle">Tokenization</text>
		<text class="h1 title-line" x="965" y="575" fill="#F7A41D" text-anchor="middle">step by step</text>

		<g class="title-line">
			<text class="h1" x="965" y="825" fill="#F7A41D" text-anchor="middle">in &nbsp;&nbsp;&nbsp;</text>

			<svg id="zig-logo" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="-1 0 154 140" height="280" width="280" x="965" y="600">
				<g fill="#F7A41D">
					<g id="logo-left-side">
						<polygon points="46,22 28,44 19,30"></polygon>
						<polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"></polygon>
						<polygon points="31,95 12,117 4,106"></polygon>
					</g>
					<g id="logo-middle">
						<polygon points="56,22 62,36 37,44"></polygon>
						<polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"></polygon>
						<polygon points="116,95 97,117 90,104"></polygon>
						<polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"></polygon>
						<polygon points="150,0 52,117 3,140 101,22"></polygon>
					</g>
					<g id="logo-right-side">
						<polygon points="141,22 140,40 122,45"></polygon>
						<polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"></polygon>
						<polygon points="125,95 130,110 106,117"></polygon>
					</g>
				</g>
			</svg>
		</g>

		<text class="h2" id="by-line" x="960" y="1025" text-anchor="middle">by Niles Salter / @Validark</text>

		<script>
			global_animations.push({
				section: "title",
				selector: ".title-line, #zig-logo",
				slide_num: 0,
				animation_duration: "10s",
				keyframes: {
					0:   { "letter-spacing": "-1em", opacity: 0, transform: "scale(0.25) translate(140rem, 50rem)", "font-size": "1rem" },
					30:  { opacity: 1, "font-size": "8rem" },
					100: { "letter-spacing": 0, opacity: 1, transform: "scale(1) translate(0, 0)", "font-size": "8rem" },
				}
			}, {
				section: "title",
				selector: ".title-line > text",
				slide_num: 0,
				animation_duration: "10s",
				keyframes: {
					0:   { "letter-spacing": "-1em" },
					100: { "letter-spacing": 0 },
				}
			}, {
				section: "title",
				selector: "#by-line",
				slide_num: 0,
				animation_delay: "10s",
				animation_duration: "10s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { "letter-spacing": "-1em", opacity: 0 },
					25:  { opacity: 1 },
					100: { "letter-spacing": 0, opacity: 1 },
				}
			}, {
				section: "title",
				selector: "#logo-left-side",
				slide_num: 0,
				animation_duration: "10s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(75px)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			}, {
				section: "title",
				selector: "#logo-right-side",
				slide_num: 0,
				animation_duration: "10s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(-75px)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			}, {
				section: "title",
				selector: "#logo-middle",
				slide_num: 0,
				animation_duration: "10s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(0)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			});
		</script>
	</g>

	<!-- <g class="slide" id="itinerary">
		<text id="itinerary-title" class="h2" x="960" y="125" text-anchor="middle">Itinerary:</text>

		<script>
			document.getElementById("itinerary-title").insertAdjacentHTML("afterend", [
				"What is SIMD & Why?",
				"How do I wield it?"
			].map((x, i) => `&lt;text click class="h2" id="itinerary-${i}" x="160" y="${225+50+i*125}" text-anchor="start"&gt;- ${x}&lt;/text&gt;`).join(""))

			document.getElementById("itinerary-1").insertAdjacentHTML("afterend", [
				"How do I setup Godbolt?",
				"How much can the compiler do?",
				"What can SIMD do?",
				"How do I find intrinsics?",
				"Other resources?",
			].map((x, i) => `&lt;text click class="h2" style="font-size: 3rem;" x="300" y="${225+50+1.75*125+i*75}" text-anchor="start"&gt;${i + 1}. ${x}&lt;/text&gt;`).join(""))
		</script>
	</g> -->

	<!-- <g class="slide" id="definitions">
		<text id="definitions-title" class="h2" x="960" y="125" text-anchor="middle">Definitions:</text>

		<script>
			document.getElementById("definitions-title").insertAdjacentHTML("afterend", [
				"SIMD: Single Instruction, Multiple Data",
				"SWAR: SIMD within a Register",
			].map((x, i) => `&lt;text click class="h3" x="60" y="${225+50+i*125}" text-anchor="start"&gt;- ${x}&lt;/text&gt;`).join(""))
		</script>
	</g> -->


	<g class="slide" id="basic-idea">
		<text id="basic-idea-title" class="h2" x="960" y="125" text-anchor="middle">The basic idea</text>

		<g click class="code" x="200" y="200" width="1920" line-height="70" line-num-indent="80" line-indent="100" hide-line-numbers lang="asm" hide-background>
		add     rdi, r8
        add     rsi, r9
        add     rdx, r10
        add     rcx, r11
		</g>

		<g click id="transformed-adds">
			<text class="h1" style="font-size: 12rem;" fill="#fff" x="860" y="325" text-anchor="middle">&rArr;</text>

			<g class="code" x="900" y="200" width="1920" line-height="70" line-num-indent="80" line-indent="100" hide-line-numbers lang="asm" hide-background>
			vpaddq  ymm0, ymm1, ymm0
			</g>
		</g>

		<text click class="h2" id="basic-utility" x="250" y="600" text-anchor="start">Why this is helpful:</text>

		<script>
		{
			let iter = 0;
			let iter2 = 0;
			let y = 225+50+4.5*100-65-50;
			let tmp = 0;

		document.getElementById("basic-utility").insertAdjacentHTML("afterend", [
			"Decrease instruction count",
				"- Reduces pressure on CPU front-end (decoder+scheduler+&lt;tspan fill=\"green\"&gt;i$&lt;/tspan&gt;)",
				"-- Lowers power usage &lt;tspan style=\"font-size: 4rem\"&gt;&rArr;&lt;/tspan&gt; higher clock speeds",
				"- Makes &lt;tspan class=\"highlighted\"&gt;pipelining&lt;/tspan&gt; more likely",
			"Increase work per instruction",
				"- We can only execute so many &lt;tspan class=\"highlighted\"&gt;&micro;ops per cycle&lt;/tspan&gt;",
		].map((x, i) =>
			x.slice(0, 2) === '--'
				? `&lt;text click class="h4" x="80" y="${tmp=y,y+=50+10,y}" text-anchor="start"&gt;${["i", "ii"][iter2++]}. ${x.slice(2)}&lt;/text&gt;`
				: x[0] === '-'
					? `&lt;text click class="h4" x="60" y="${tmp=y,y+=50+10,y}" text-anchor="start"&gt;${x}&lt;/text&gt;`
					: `&lt;text click class="h3" x="10" y="${tmp=y,y+=65+10,y}" text-anchor="start"&gt;${++iter}. ${x}&lt;/text&gt;`
		).join(""))
		}
		</script>
	</g>

	<!-- <g class="slide" id="live-coding-break">
		<image click x="183.75" y="-25" width="1552.5" height="1147.7" href="/images/bell_curve_instruction_count.avif">
		</image>
	</g> -->

	<g class="slide" id="keywords-lookup" clicks="5">
		<g id="columnCounts" class="code" lang="zig" x="0" y="10" width="1920" line-height="70" line-num-indent="80" line-indent="245" hide-line-numbers hide-background>
			export fn columnCounts(chunk: @Vector(16, u8)) @Vector(16, u8) {
		</g>

		<text id="bit-thing-1" class="bits bits-match-color" align="columnCounts" line="5" small-label="alpha_num_und">^^^^^^~^^~^^^^^^^^^^^^~^^^^^~~~^^^^^^~^^~~^^~~~~^^^^^^~^^~~^^~~~</text>

		<text id="bit-thing-2" class="bits bits-match-color" align="columnCounts" line="6" small-label="alpha_num_und << 1">^^^^^^~^^~^^^^^^^^^^^^~^^^^^~~~^^^^^^~^^~~^^~~~~^^^^^^~^^~~^^~~~</text>

		<text id="bit-thing-3" class="bits bits-match-color" align="columnCounts" line="7" small-label="alpha_num_und >> 1">^^^^^^~^^~^^^^^^^^^^^^~^^^^^~~~^^^^^^~^^~~^^~~~~^^^^^^~^^~~^^~~~</text>

		<text id="bitsy-1" class="bits bits-match-color" align="columnCounts" line="1" label="start_pos">^~~~~~~^~~^~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~^~~~~</text>
		<text id="bitsy-3" class="bits bits-match-color" align="columnCounts" line="3" label="end_pos">~~~~~^~~^~~~~~~~~~~~~^~~~~~^~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~^~~~</text>

		<text id="bitsy-2" class="bits bits-match-color" align="columnCounts" line="2" label="start_indices">^~~~~~~^~~^~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~^~~~~</text>
		<text id="bitsy-4" class="bits bits-match-color" align="columnCounts" line="4" label="end_indices">~~~~~^~~^~~~~~~~~~~~~^~~~~~^~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~^~~~</text>

		<text id="bitsy-6" class="bits bits-match-color" align="columnCounts" line="3" label="lengths">~~~~~^~~^~~~~~~~~~~~~^~~~~~^~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~^~~~</text>

		<script>{
			const str = new Array(64).fill(0).map((_, i) => i).map((x, i) => `&lt;text id="iota" class="bits bits-match-color2" align="columnCounts" line="-1"&gt;${"&nbsp;".repeat(x)}&lt;tspan class="bits-small"&gt;&lt;tspan class="space-small"&gt;&nbsp;&lt;/tspan&gt;${x.toString().padStart(2, "")}&lt;/tspan&gt;&lt;/text&gt;`).join("\n");
			document.getElementById("bitsy-6").insertAdjacentHTML("afterend", str);
		}</script>

		<style>
			.space-small {
				font-size: 15px;
			}
		</style>
		<script type="text/javascript">
			for (const id of ["bit-thing-1", "bit-thing-2", "bit-thing-3"]) {
				const obj = document.getElementById(id);
				let s = [...obj.innerHTML]
					.map(e => e === '^' ? '1' : '.').join('')
					//.replaceAll(/1+/g, e => String.fromCharCode(60) + String.fromCharCode(45).repeat(e.length-2) + String.fromCharCode(62))
					;

				obj.innerHTML = s;
			}

			function sub(a, b) {
				return a.map((_, i) => a[i] - b[i] + 1);
			}

			for (let j = 0; (j += 2) <= 6; ) {
				const bitsy_2_positions = j === 6
					? sub([...document.getElementById(`bitsy-4`).innerHTML.matchAll(/\^/g)].map(({ index }) => index),
					      [...document.getElementById(`bitsy-2`).innerHTML.matchAll(/\^/g)].map(({ index }) => index))
					: [...document.getElementById(`bitsy-${j}`).innerHTML.matchAll(/\^/g)].map(({ index }) => index);

				post_processes.push(() => {
					if (j !== 6) {
						const bitsy = document.getElementById(`bitsy-${j - 1}`);
						const { innerHTML } = bitsy;
						bitsy.innerHTML = bitsy.innerHTML
							.replaceAll('^', '&lt;tspan class="up-arr-1"&gt;' + '1' + '&lt;/tspan&gt;')
							.replaceAll(/~+/g, e => `&lt;tspan class="bits-underscore"&gt;${'.'.repeat(e.length)}&lt;/tspan&gt;`);
					}

					{
						const bitsy = document.getElementById(`bitsy-${j}`);
						let i = 0;

						bitsy.innerHTML = bitsy.innerHTML
							.replaceAll(/\^([^~]*?)~/g, (_, e, r) => {
								const str = "" + bitsy_2_positions[i++];
								const s = '&lt;tspan class="bits-underscore-2-replacement"&gt;&nbsp;&lt;/tspan&gt;';
								return (str.length === 1 ? (i <= 2 ? '' : s) + str + e + '~' : str + e) + s;
							})
							.replaceAll(/~+/g, e => `&lt;tspan class="bits-underscore-2"&gt;${'.'.repeat(e.length)}&lt;/tspan&gt;`)
						;
					}
				});
			}

			post_processes.push(() => {
				const obj = document.getElementById("bit-thing-2");
				obj.innerHTML = "&lt;tspan id=\"shr-qq\"&gt;.&lt;/tspan&gt;" + obj.innerHTML;
				[...obj.getElementsByClassName("code-curly-0")].pop().id = "shr-qq-elim";
				// console.log({k: obj.innerHTML});
			});

			post_processes.push(() => {
				const obj = document.getElementById("bit-thing-3");
				const xobj = [...obj.getElementsByClassName("code-keyword")].shift();
				xobj.innerHTML = xobj.innerHTML.replace("1", "&lt;tspan id=\"shl-qq-elim\"&gt;1&lt;/tspan&gt;");
				obj.innerHTML = obj.innerHTML + "&lt;tspan id=\"shl-qq-enter\"&gt;.&lt;/tspan&gt;"
			});


			global_animations.push({
				section: "keywords-lookup",
				selector: "#shl-qq-enter",
				slide_num: 1,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					  0:   { "letter-spacing": "-32px", opacity: 0 },
					 80:  { opacity: 1 },
					100: { "letter-spacing": "-6px", opacity: 1 },
				}
			}, {
				section: "keywords-lookup",
				selector: "#shl-qq-elim",
				slide_num: 1,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					  0:   { "letter-spacing": "-6px", opacity: 1 },
					 70:  { opacity: 0 },
					100: { "letter-spacing": "-32px", opacity: 0 },
				}
			}, {
				section: "keywords-lookup",
				selector: "#shr-qq-elim",
				slide_num: 1,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					  0:   { "letter-spacing": "-6px", opacity: 1 },
					 20:  { opacity: 1 },
					100: { "letter-spacing": "-32px", opacity: 0 },
				}
			}, {
				section: "keywords-lookup",
				selector: "#shr-qq",
				slide_num: 1,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					  0:   { "letter-spacing": "-32px", opacity: 0 },
					 20:  { opacity: 0 },
					100: { "letter-spacing": "-6px", opacity: 1 },
				}
			}, {
				section: "keywords-lookup",
				selector: "#bitsy-1",
				slide_num: 1,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					0:   { transform: "translateY(-40px)" },
					100: { transform: "translateY(0)" },
				}
			}, {
				section: "keywords-lookup",
				selector: "#bitsy-3",
				slide_num: 1,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					0:   { transform: "translateY(-180px)" },
					100: { transform: "translateY(0)" },
				}
			}, {
				section: "keywords-lookup",
				selector: ".up-arr-1",
				slide_num: 1,
				animation_duration: "2s",
				keyframes: {
					0:   { "baseline-shift": "-10px" },
					100: { "baseline-shift": 0 },
				}
			}, {
				section: "keywords-lookup",
				selector: ".bits-underscore, #bitsy-1-label, #bitsy-3-label",
				slide_num: 1,
				animation_duration: "2s",
				keyframes: {
					0:   { opacity: 0 },
					100: { opacity: 1 },
				}
			}, {
				section: "keywords-lookup",
				selector: ".bits-underscore-2",
				slide_num: 3,
				animation_duration: "3s",
				continuous: true,
				keyframes: {
					0:   { "letter-spacing": "-6px", opacity: 1 },
					80:  { opacity: 0 },
					100: { "letter-spacing": "-32px", opacity: 0 },
				}
			}, {
				section: "keywords-lookup",
				selector: ".bits-underscore-2-replacement",
				slide_num: 3,
				animation_duration: "3s",
				continuous: true,
				keyframes: {
					0:   { "letter-spacing": "-32px" },
					100: { "letter-spacing": "-6px" },
				}
			}, {
				section: "keywords-lookup",
				selector: "#bitsy-2, #bitsy-4, #bitsy-2-label, #bitsy-4-label",
				slide_num: 2,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					0:   { opacity: 0 },
					100: { opacity: 1 },
				}
			}, {
				section: "keywords-lookup",
				selector: "#bitsy-6, #bitsy-6-label",
				slide_num: 4,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					0:   { opacity: 0 },
					100: { opacity: 1 },
				}
			}, {
				section: "keywords-lookup",
				selector: "#bitsy-4, #bitsy-4-label, #bitsy-3, #bitsy-3-label, #bitsy-1, #bitsy-1-label",
				slide_num: 4,
				animation_duration: "0.5s",
				continuous: true,
				skip_auto_prev_state: true,
				keyframes: {
					0:   { opacity: 1, transform: "translateY(0)" },
					100: { opacity: 0, transform: "translateY(0)" },
				}
			});
		</script>
	</g>


	<g class="slide" id="tree" clicks="18:12,25:7,31:3,44:5,55,1">
		<g class="code" id="phase-1-code" x="0" y="00" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig" steps="1,2:7,9:5,14:2,18,20,21,23:2,26,102,103,105,106,107:14,122:10,133:9,27,29,30,31:6,38:4,43:6,49:6,56:3,60,62:7,70,72:2,75:2,78:2,81:2,84:3,88:12">
			var bitstrs: struct {
				carriages: [8]u64,
				newlines_or_eof: [8]u64,
				slashes: [8]u64,
				backslashes: [8]u64,
				quotes: [8]u64,
				apostrophes: [8]u64,
				bad_controls: [8]u64,
				ats_maybe_in_string_or_comment: [8]u64,
				digits_maybe_in_string_or_comment: [8]u64,
				whitespaces_maybe_in_string_or_comment: [8]u64,
				alpha_underscores_maybe_in_string_or_comment: [8]u64,
				possible_one_char_symbols_maybe_in_string_or_comment: [8]u64,
				prelim_double_char_ends: [8]u64,
				prelim_triple_char_ends: [8]u64,
			} = undefined;

			var classified_chunks: [8]@Vector(64, u8) = undefined;

			for (0..8) |i| {
				const cursor = cur[i * 64 ..];

				// Real version reads bytes after end-of-file as newlines.
				var chunk: @Vector(64, u8) = cursor.ptr[0..64].*;

				var classified = vperm2(classifier, chunk);
				const non_ASCII = v_op(chunk, .@">=", 0x80);

				if (!isZero(non_ASCII)) {
					@branchHint(.unlikely);
					classified = @select(
						u8,
						@as(@Vector(64, bool), @bitCast(non_ASCII)),
						@as(@Vector(64, u8), @splat(CharClasses.unknown)),
						classified,
					);

					if (try utf8_checker.validateChunk(
						chunk,
						cursor.ptr == source.ptr,
					)) {
						@branchHint(.unlikely);
						chunk = @select(
							u8,
							@as(@Vector(64, bool), @bitCast(@as(u64, 0b111))),
							@as(@Vector(64, u8), @splat('\n')),
							chunk,
						);
						classified = @select(
							u8,
							[1]bool{true} ** 3 ++ [1]bool{false} ** 61,
							[1]u8{classifier['\n']} ** 64,
							classified,
						);
					}
				} else if (utf8_checker.is_invalid_place_to_end)
					// isZero(non_ASCII)
					return error.InvalidUtf8;

				classified_chunks[i] = classified;

				bitstrs.carriages[i]                      = v_eq(chunk, '\r');
				bitstrs.newlines_or_eof[i]                = v_eq(chunk, '\n');
				bitstrs.slashes[i]                        = v_eq(chunk, '/');
				bitstrs.backslashes[i]                    = v_eq(chunk, '\\');
				bitstrs.quotes[i]                         = v_eq(chunk, '"');
				bitstrs.apostrophes[i]                    = v_eq(chunk, '\'');
				bitstrs.ats_maybe_in_string_or_comment[i] = v_eq(chunk, '@');

				bitstrs.bad_controls[i] = v_eq(classified, .bad_control);

				bitstrs.digits_maybe_in_string_or_comment[i] =
					v_eq(classified, .digit);

				bitstrs.whitespaces_maybe_in_string_or_comment[i] =
					v_eq(classified, .whitespace);

				bitstrs.alpha_underscores_maybe_in_string_or_comment[i] =
					v_eq(classified, .alpha_underscore);

				bitstrs.possible_one_char_symbols_maybe_in_string_or_comment[i] =
					v_op(classified, .@"<=", last_symbol_char_class);

				bitstrs.prelim_double_char_ends[i],
				bitstrs.prelim_triple_char_ends[i] = multi_char_symbol_parser
					.getMultiCharMasks(classified);

				if (cursor.len < 64) {
					@branchHint(.unlikely);
					for (i + 1..8) |j| {
						// Because we are still going to be using 512-bit bitstrs,
						// let's zero the rest of the data out.
						inline for (std.meta.fields(@TypeOf(bitstrs))) |field| {
							@field(bitstrs, field.name)[j] = 0;
						}
						classified_chunks[i] = @splat(classifier['\n']);
					}
					break;
				}
			}

			fn vperm2_with_table(indices: @Vector(64, u8)) @Vector(64, u8) {
				var result: @Vector(64, u8) = undefined;

				inline for (0..64) |i| {
					result[i] = switch (@as(u7, @truncate(indices[i]))) {
						'*' => 1,
						'=' => 2,
						'+' => 3,
						'<' => 4,
						'?' => 5,
						'>' => 7,
						'|' => 8,
						'^' => 9,
						'-' => 10,
						'&' => 11,
						'!' => 12,
						'/' => 13,
						'%' => 14,
						'.' => 15,

						'(' => 128,
						')' => 129,
						',' => 131,
						':' => 132,
						';' => 134,
						'[' => 135,
						']' => 136,
						'{' => 139,
						'}' => 142,
						'~' => 144,

						'@' => 149,
						'\\' => 159,
						'#', '$', '`' => 160,
						'\n', '\r', '\t', ' ' => 162,
						'"' => 172,
						'\'' => 179,
						'a'...'z', 'A'...'Z', '_' => 180,
						0...'\t'-1, '\n'+1...'\r'-1, '\r'+1...' '-1, 0x7F => 187,
						'0'...'9' => 197,
					};
				}

				return result;
			}
		</g>
	<script>
		document.getElementById("tree").setAttribute("clicks", document.getElementById("phase-1-code").getAttribute("steps"));
	</script>
	</g>

	<g class="slide" id="get-multi-char-masks">
		<g class="code" id="phase-1a-code" x="0" y="0" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig"
		steps="1,2,4:3,8:10,19,21:5,28,30:8,38,39:2,41:3,47:5,52,54:5,60:5,66,67,68:6,75,76,77:6,84,85,87:4">
			fn getMultiCharMasks(self: *@This(), classified: @Vector(64, u8))
				struct { u64, u64 }
			{
                comptime var first_char_data: @Vector(16, u8) = @splat(0);
                comptime var second_char_data: @Vector(16, u8) = @splat(0);
                comptime var third_char_data: @Vector(16, u8) = @splat(0);

                const Channels = packed struct {
                    bar_mod: u1 = 0,
                    eql: u1 = 0,
                    dot: u1 = 0,
                    arrow: u1 = 0,
                    @"<": u1 = 0,
                    @">": u1 = 0,
                    dot_question: u1 = 0,
                    self: u1 = 0,
                };

                comptime for (std.meta.fields(Channels)) |o| {
                    for (
						.{
							&first_char_data,
							&second_char_data,
							&third_char_data
						},
						@as([3][]const u8, switch (@field(
							std.meta.FieldEnum(Channels),
							o.name,
						)) {
							.bar_mod      => .{ "-+*",            "%|",   "="  },
							.eql          => .{ "|=!%^+*/&<>-",   "=",    ""   },
							.self         => .{ "|.+*",         "|.+*",   "."  },
							.dot          => .{ ".",              "*",    "*"  },
							.arrow        => .{ "-=",             ">",    ""   },
							.@"<"         => .{ "<",              "<",    "|=" },
							.@">"         => .{ ">",              ">",    "="  },
							.dot_question => .{ ".",              "?",    ""   },
						})) |dest_char_data, string| {
                        var state: Channels = .{};
                        @field(state, o.name) = 1;
                        for (string) |c| {
                            dest_char_data[hashOpChars(c)] |= @bitCast(state);
                        }
                    }
                };

                comptime var state_without_self: Channels =
					@bitCast(~@as(
						@typeInfo(Channels).@"struct".backing_integer.?,
						0
					));
                state_without_self.self = 0;

                const prev1_classified = shift_in_prev(
					1,
					classified,
					self.prev_classified
				);

                const prev2_classified = shift_in_prev(
					2,
					classified,
					self.prev_classified
				);

                const double_char_ends = vpshufb(second_char_data, classified) &
                    vpshufb(first_char_data, prev1_classified) &
                    @select(
						u8,
						prev1_classified == classified,
						@as(@Vector(64, u8), @splat(0b11111111)),
						@as(@Vector(64, u8), @splat(@bitCast(state_without_self)))
					);

                const triple_char_ends = vpshufb(third_char_data, classified) &
                    shift_in_prev(1, double_char_ends, self.prev_doubleCharEnds) &
                    @select(
						u8,
						prev2_classified == prev1_classified,
						@as(@Vector(64, u8), @splat(0b11111111)),
						@as(@Vector(64, u8), @splat(@bitCast(state_without_self)))
					);

                self.prev_classified = classified;
                self.prev_doubleCharEnds = double_char_ends;

                return .{
                    @as(u64, @bitCast(double_char_ends != @splat(0))),
                    @as(u64, @bitCast(triple_char_ends != @splat(0))),
                };
            }
		</g>
		<script>
			document.getElementById("get-multi-char-masks").setAttribute("clicks", document.getElementById("phase-1a-code").getAttribute("steps"));
		</script>
	</g>

	<g class="slide" id="phase-2a-stuff">
		<g class="code" id="phase-2a-code" x="0" y="0" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig"
		steps="1:14,16,18:4,22,24,111,112:5,118:3,121,122,123,125:2,125:2,125:2,128,128,129,129,130,131,24,26,27,33:2,33:2,33:2,36:2,39:2,42:2,45:2,48:2,56:6,63:3,67:4,72:4,76,78:2,81,83,82,86,87,90,88:4,94,92:4,96,98,99,100,101,103:4">
			const carriages: uint = bitstrs.carriages;
			const newlines_or_eof: uint = bitstrs.newlines_or_eof;
			const slashes: uint = bitstrs.slashes;
			const backslashes: uint = bitstrs.backslashes;
			const quotes: uint = bitstrs.quotes;
			const apostrophes: uint = bitstrs.apostrophes;
			const ats_maybe_in_string_or_comment: uint = bitstrs.ats_maybe_in_string_or_comment;
			const bad_controls: uint = bitstrs.bad_controls;
			const digits_maybe_in_string_or_comment: uint = bitstrs.digits_maybe_in_string_or_comment;
			const whitespaces_maybe_in_string_or_comment: uint = bitstrs.whitespaces_maybe_in_string_or_comment;
			const alpha_underscores_maybe_in_string_or_comment: uint = bitstrs.alpha_underscores_maybe_in_string_or_comment;
			const possible_one_char_symbols_maybe_in_string_or_comment: uint = bitstrs.possible_one_char_symbols_maybe_in_string_or_comment;
			const prelim_double_char_ends: uint = bitstrs.prelim_double_char_ends;
			const prelim_triple_char_ends: uint = bitstrs.prelim_triple_char_ends;

			if (!isZero(bad_controls)) return error.InvalidControlCharacter;

			// '\r' is only valid when there is a '\n' immediately after.
			// Will also incorrectly match /\r$/, which we check at the end.
			const offender = ~newlines_or_eof &
				shld(carriages, 1, prev_carriages);
			if (!isZero(offender)) return error.InvalidCarriageReturn;

			const escaped = getEscapedPositions(&carry, backslashes);

			const unescaped_quotes = quotes & ~escaped;
			const unescaped_apostrophes = apostrophes & ~escaped;

			// We intentionally shift right here
			// (i.e. backwards in the source file) because
			// we want these to start on the first character
			// instead of the second.
			const double_slash_starts =
				slashes & (shr(slashes, 1) | carry.get(.slashes));

			const double_backslash_starts =
				backslashes & (shr(backslashes, 1) | carry.get(.backslashes));

			const comment_bounds_incl_carry =
				double_slash_starts | carry.get(.inside_comments);

			const line_string_bounds_incl_carry =
				double_backslash_starts | carry.get(.inside_line_strings);

			const quote_bounds_incl_carry = unescaped_quotes ^
				carry.get(.inside_quotes_incl_start_and_carry);

			const apostrophe_bounds_incl_carry = unescaped_apostrophes ^
				carry.get(.inside_apostrophes_incl_start_and_carry);

			// We might have the end of some string/char_literal at the
			// beginning of the chunk, and in this case we need the (pseudo)
			// start and end character to be the same. That's why we handle
			// this separately from the loop that follows, which only permits
			// starts to be different from ends.
			const first_char_ends_string = disjoint_or(
				unescaped_quotes &
					carry.get(.inside_quotes_incl_start_and_carry),
				unescaped_apostrophes &
					carry.get(.inside_apostrophes_incl_start_and_carry),
			);

			// Bitstrings that mark where each token begins and ends
			var all_starts: uint = first_char_ends_string;
			var all_ends: uint = first_char_ends_string;

			const MSb: uint = @bitCast(
				@as(std.meta.Int(.unsigned, @bitSizeOf(uint)), 1) <<
					(VLEN - 1)
			);

			var all_bounds_incl_carry = quote_bounds_incl_carry |
				apostrophe_bounds_incl_carry |
				comment_bounds_incl_carry |
				line_string_bounds_incl_carry;
			const carriages_or_newlines_or_eof = carriages | newlines_or_eof;
			// https://zig.godbo.lt/z/as55c8Pbr
			var iter = ~carriages_or_newlines_or_eof &
				shld(carriages_or_newlines_or_eof, 1, MSb);

			while (true) {
				const starts = all_bounds_incl_carry & ~sub(
					all_bounds_incl_carry | carriages_or_newlines_or_eof,
					iter,
				);
				all_starts |= starts;
				var interleaved = carriages_or_newlines_or_eof;
				interleaved |= quote_bounds_incl_carry & sub(
					carriages_or_newlines_or_eof,
					starts & quote_bounds_incl_carry,
				);
				interleaved |= apostrophe_bounds_incl_carry & sub(
					carriages_or_newlines_or_eof,
					starts & apostrophe_bounds_incl_carry
				);
				interleaved &= ~starts;

				const cur_ends = interleaved & ~sub(interleaved, starts);
				all_ends |= cur_ends;
				iter = cur_ends & ~carriages_or_newlines_or_eof;
				all_bounds_incl_carry &= ~cur_ends;

				if (isZero(iter)) {
					@branchHint(.likely);
					break;
				}
			}

		...

		fn getEscapedPositions(carry: *Carry, backslashes: uint) uint {
            // --------------------------------------------------------------
            // This code is brought to you courtesy of simdjson, licensed
            // under the Apache 2.0 license
            // Credit to John Keiser (@jkeiser) for designing this algorithm.
            // See https://github.com/simdjson/simdjson/pull/2042

            const ODD_BITS: uint = @bitCast(
				[_]u8{0xaa} ** @divExact(@bitSizeOf(uint), 8)
			);
            const next_is_escaped = carry.get(.next_is_escaped);
            const potential_escape = backslashes & ~next_is_escaped;
            const maybe_escaped = shl(potential_escape, 1);

            const even_series =
				sub(maybe_escaped | ODD_BITS, potential_escape);

            const esc_and_term = even_series ^ ODD_BITS;
            const escaped = esc_and_term ^ (backslashes | next_is_escaped);
            carry.set(.next_is_escaped, esc_and_term & backslashes);
            return escaped;
            // --------------------------------------------------------------
        }









		
		</g>
		<script>
			document.getElementById("phase-2a-stuff").setAttribute("clicks", document.getElementById("phase-2a-code").getAttribute("steps"));
		</script>
	</g>

	<g class="slide" id="phase-2b">
		<g class="code" id="phase-2b-code" x="0" y="0" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig"
		steps="1,2,6:2,11:4,18:4,27,28:3,31:6,37:6,43:6,49:6,56:3,59:3,62:3,66,72,73:2,75:2,78:2,81:2,84:3,88:3,92:3,96:2,99:2,102:2,105,106,107,108,112:7,162,169:3,180:4,198,202,219,220,232,233,235,248,249,290:2,296:4,306:2,308,310:4,120:8,129,130,132:2,135:3,139,141:2,144:3,148:2,151,152,154:2,157,158">
		const inside_strings_and_comments_including_start =
			sub(all_ends, all_starts);

		// Revise `all_ends` such that tokens do
		// not include the carriages_or_newlines_or_eof
		all_ends = (all_ends & ~carriages_or_newlines_or_eof) |
			shr(all_ends & carriages_or_newlines_or_eof, 1);

		// Add a dummy end-bit if we ended inside a
		// string/comment/line_string/char_literal
		all_ends = disjoint_or(
			all_ends,
			inside_strings_and_comments_including_start & MSb
		);

		//       "|"
		//        ^ chunk break
		const is_first_char_inside_string_or_comment =
			carry.get(.inside_strings_and_comments_including_start) &
			~first_char_ends_string &
			~carriages_or_newlines_or_eof;


		// Find out which characters are inside a string/char-literal/comment.
		// We need the carry because all_starts might
		// include the first character as a pseudo-start.
		const last_start = isolateMSb(all_starts);
		const ends_in_str_or_comm = isolateLastBit(
			inside_strings_and_comments_including_start
		);
		carry.set(
			.inside_quotes_incl_start_and_carry,
			ends_in_str_or_comm & @intFromBool(
				!isZero(last_start & quote_bounds_incl_carry),
			),
		);
		carry.set(
			.inside_apostrophes_incl_start_and_carry,
			ends_in_str_or_comm & @intFromBool(
				!isZero(last_start & apostrophe_bounds_incl_carry),
			),
		);
		carry.set(
			.inside_comments,
			ends_in_str_or_comm & @intFromBool(
				!isZero(last_start & comment_bounds_incl_carry),
			),
		);
		carry.set(
			.inside_line_strings,
			ends_in_str_or_comm & @intFromBool(
				!isZero(last_start & line_string_bounds_incl_carry),
			),
		);

		const ats                =
			~inside_strings_and_comments_including_start &
			ats_maybe_in_string_or_comment;
		const digits             =
			~inside_strings_and_comments_including_start &
			digits_maybe_in_string_or_comment;
		const alpha_underscores  =
			~inside_strings_and_comments_including_start &
			alpha_underscores_maybe_in_string_or_comment;

		const alpha_numeric_underscores = alpha_underscores | digits;

		// Why do we not pull in the last bit from the previous chunk when
		// shifting by 1? Why do we unconditionally shift in a zero bit?
		// Because we need to have a start or pseudo-start at the beginning
		// of a chunk when we have a token that crosses chunks.
		const follows_at = shl(ats, 1);
		const follows_non_at_alpha_numeric_underscore =
			~shl(alpha_numeric_underscores, 1) & ~follows_at;
		const identifier_or_number_starts = alpha_numeric_underscores &
			follows_non_at_alpha_numeric_underscore;

		const string_identifier_started_before_ext_chunk =
			unescaped_quotes & carry.get(.ats);

		const builtin_started_before_ext_chunk =
			alpha_underscores & carry.get(.ats);

		const is_comment_opener_split_between_ext_chunks = slashes &
			carry.get(.slashes) &
			~carry.get(.inside_strings_and_comments_including_start);

		const is_line_string_opener_split_between_ext_chunks = backslashes &
			carry.get(.backslashes) &
			~carry.get(.inside_strings_and_comments_including_start);

		const identifier_or_number_or_builtin_with_letters_started_before_ext_chunk =
			carry.get(.identifier_or_number_or_builtin_ends) &
			alpha_numeric_underscores;

		const identifier_or_number_or_builtin_ends =
			alpha_numeric_underscores & ~shr(alpha_numeric_underscores, 1);

		const builtin_starts = (ats & shr(alpha_underscores, 1)) |
			builtin_started_before_ext_chunk;

		const string_identifier_starts = (ats & shr(unescaped_quotes, 1)) |
			string_identifier_started_before_ext_chunk;

		all_starts &= ~(follows_at & unescaped_quotes);
		all_starts |= builtin_starts | string_identifier_starts;
		all_starts |= identifier_or_number_starts;
		all_ends |= identifier_or_number_or_builtin_ends;

		// These may indicate the first char of a chunk, when a multi-char
		// symbol started in the previous chunk
		const double_char_ends, const triple_char_ends =
			multi_char_symbol_parser.refineMultiCharEndsMasks(
				&carry,
				prelim_double_char_ends,
				prelim_triple_char_ends,
				inside_strings_and_comments_including_start,
			);

		const single_char_ends =
			possible_one_char_symbols_maybe_in_string_or_comment &
			~inside_strings_and_comments_including_start &
			// Delete single_char_ends that are already covered by
			// `double_char_ends` and `triple_char_ends`
			~(double_char_ends | shr(double_char_ends, 1)) &
			~(triple_char_ends | shr(triple_char_ends, 1) |
				shr(triple_char_ends, 2));

		const multi_char_symbol_ends = double_char_ends | triple_char_ends;
		const all_symbol_ends = single_char_ends | multi_char_symbol_ends;

		const multi_char_symbol_starts =
			shr(double_char_ends, 1) | shr(triple_char_ends, 2);

		const _1: uint = @bitCast(
			@as(std.meta.Int(.unsigned, @bitSizeOf(uint)), 1),
		);

		const multi_char_has_two_chars_in_prev_chunk = _1 & triple_char_ends;

		const multi_char_has_one_char_in_prev_chunk = _1 &
			(double_char_ends | shr(triple_char_ends, 1));

		const multi_char_starts_before_chunk =
			multi_char_has_one_char_in_prev_chunk |
			multi_char_has_two_chars_in_prev_chunk;

		const all_multi_char_starts =
			multi_char_symbol_starts | multi_char_starts_before_chunk;

		all_starts |= single_char_ends | all_multi_char_starts;
		all_ends |= all_symbol_ends;

		const invalids = bad_controls | ~(sub(all_ends, all_starts) |
			all_ends | whitespaces_maybe_in_string_or_comment);

		all_ends |= invalids; // ~all_starts & invalid_non_newlines;
		all_starts |= invalids;

		...

		fn refineMultiCharEndsMasks(
			self: *@This(),
			carry: *Carry,
			prelim_double_char_ends: uint,
			prelim_triple_char_ends: uint,
			inside_strings_and_comments_including_start: uint,
		) struct { uint, uint } {
			const triple_char_ends =
				~inside_strings_and_comments_including_start &
				prelim_triple_char_ends;

			// The rule for multi-char symbol matching is that we always want
			//  to match the longest possible symbol that we can.
			// That means that if there is a 3-char-end in the next position
			// from a two-char-end, we can unset the two-char-end bit.
			//  E.g.              a +|= b
			//double_char_ends <- 0001000 (we unset the 1 bit)
			//triple_char_ends <- 0000100
			const double_char_ends =
				~inside_strings_and_comments_including_start &
				prelim_double_char_ends &
				~shr(triple_char_ends, 1);

			// The idea is to iterate over a bitstring which is the
			// bitwise-OR of `double_char_ends` and `triple_char_ends`.
			// We iteratively find the lowest 1 bit, unset that bit,
			// then unset one, possibly two bits after that bit, and repeat.
			// We would unset two bits after if that bit corresponds to the
			// end of a triple-char symbol. E.g.
			//
			//                                   a =>>= b
			//                                       ^ always unset this bit,
			//                        because we shouldn't match `=>` and `>>`
			//                                        ^ unset this bit if
			//                         there's a potential 3-char-symbol here.
			//                              We shouldn't match `=>` and `>>=`.
			var s = double_char_ends | triple_char_ends;

			// Will be a subset of `double_char_ends` | `triple_char_ends`,
			// but with the boundaries properly figured out.
			var ends: uint = std.mem.zeroes(uint);

			// If a triple-char-symbol-end is at the beginning of the next
			// chunk, we unset it if the last chunk ended with a multi-char
			// symbol within two chars. E.g.:
			//                   a =>>= b
			// ends <- 00000000000001
			//         next chunk -> 1100000000000000000000000000000000000000000000000000000000000000
			//                        ^ unset this one since it's a triple-
			//						  char-end within two positions of the
			//                          previous symbol-end
			//                  a =>>= b
			// ends <- 00000000000010
			//         next chunk -> 1000000000000000000000000000000000000000000000000000000000000000
			//                       ^ unset this one since it's a triple-
			//    char-end within two positions of the previous symbol-end

			s &= ~(self.delete_triple_char_pos_carry & ~double_char_ends);
			defer self.delete_triple_char_pos_carry = shr(ends, VLEN - 2);

			// This handles the case where a chunk ends on a double-char
			// symbol, only to find in the next chunk that it's a triple-char symbol.
			//                   a +%= b
			// ends <- 00000000000001
			//         next chunk -> 100000000000000000000000000000000000000000000000000000000000000
			//                       ^ this is valid because it's a triple-char-end
			//                   a ++= b
			// ends <- 00000000000001
			//         next chunk -> 100000000000000000000000000000000000000000000000000000000000000
			//                       ^ unset because it's a double-char-end
			s &= ~andn(carry.get(.ended_on_double_char), triple_char_ends);
			defer carry.set(.ended_on_double_char, ends & double_char_ends);

			while (true) {
				// Optimization: Instead of iterating over a single position
				// at once, we iterate over multiple positions at once
				// that have at least two "spaces" (not-possible-to-be-multi-
				// char-symbol chars) in between them. (Or at the start.)
				// For a "pathological" input of randomly assorted 2 and
				// 3-char symbols that overlap a lot, we have to iterate from
				// start to finish, in order, because we cannot tell in
				// parallel where all the symbols start.
				// However, in real Zig code, you typically have "spaces" in
				// between the symbols, sufficient that you can guarantee that
				// the first character in a group is the start of a
				// multi-char symbol.
				const iter = s & ~shl(s, 1) & ~shl(s, 2);
				ends |= iter;

				// We want to unset the current bit(s) pointed to by `iter`,
				// as well as the next bit, given by `iter << 1`,
				// because you can't have a 2 or 3 character symbol end in the
				// next byte after the end of a 2 or 3 character symbol.
				// E.g.         a  b
				//      iter <- 00010000
				//      s    <- 00011100
				//                  ^ always unset this bit, because we can't
				//                match both `=>` and `>>` since they overlap

				// We also want to zero two bits after, if that corresponds
				// to a non-2-char symbol `(iter << 2) & ~double_char_ends`.
				// E.g.                 .....
				//              iter <- 00100
				//              s    <- 00111
				//     double_char_ends <- 00001
				//     triple_char_ends <- 00111
				//                         ^ always unset
				//                          ^ not unset because this happens
				//                               to be a valid 2-char-symbol
				// E.g.                 ......
				//              iter <- 001000
				//              s    <- 001111
				//     double_char_ends <- 000001
				//     triple_char_ends <- 001111
				//                         ^ always unset
				//                          ^ unset because this is a valid
				// 3-char-symbol but not a valid 2-char-symbol (due to the
				// next char making a 3-char sequence, see
				// `double_char_ends &= ...` above)
				// E.g.         a =>>= b
				//      iter <- 00010000
				//      s    <- 00011100
				//                   ^ unset this bit because there's a
				// potential 3-char-symbol-end within two chars of one
				// of the `iter` bits.
				//                     I.e., we can't match both `=>`
				//                    and `>>=` because they overlap.

				s &= ~(disjoint_or(iter, shl(iter, 1)) |
					andn(shl(iter, 2), double_char_ends));
				//           ^ All 1's in `iter` must have at least
				//  two 0's between them. The compiler gives us the
				// shift+add in a single `lea` instruction :)

				if (isZero(s)) {
					@branchHint(.likely);
					break;
				}

				// We could advance each 1 bit in `iter` to the next 1 bit in `s` using `iter = s & ~(s -% iter);`,
				// but it's pretty much impossible for this loop to branch in practice, so this optimization would be pointless.
			}

			// 3-char sequences take precedence over two-char sequences, except when they are just two characters apart.
			const double_char_ends_final = (ends & ~triple_char_ends) |
				(ends & shl(ends, 2));
			const triple_char_ends_final = ends ^ double_char_ends_final;

			return .{
				double_char_ends_final,
				triple_char_ends_final,
			};
		}
		</g>

		<script>
			document.getElementById("phase-2b").setAttribute("clicks", document.getElementById("phase-2b-code").getAttribute("steps"));
		</script>

	</g>


	<g class="slide" id="conclusion">
		<text class="h2" id="" x="250" y="100" text-anchor="start">Conclusion:</text>
		<text class="h2" id="" x="250" y="300" text-anchor="start">We unlocked a new level</text>
		<text class="h2" id="" x="250" y="400" text-anchor="start">of parallelism!</text>
	</g>


	<g class="slide" id="end">
		<text class="h2" x="960" y="525" text-anchor="middle" style="font-size: 150px; letter-spacing: 0.1px;">fin</text>
	</g>
</svg>

<svg id="overlay" style="overflow: hidden; width: 100%;" y="5000" viewBox="0 0 1920 1080" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<g class="slide" id="phase-2a-stuff-overlay">
		<!-- <rect x="0" y="-70" height="1250" width="22000" style="fill: #000000EE;"/> -->
		 <rect click="6-21" x="0" y="250" height="1250" width="22000" style="fill: #100020F8;"/>
		 <g id="backslash-demo" class="code" click="6-21" lang="rainbow" x="0" y="250" width="1920" line-height="70" line-num-indent="80" line-indent="245" hide-line-numbers hide-background>
			11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11
		</g>

		<text id="" click="6-10" class="bits bits-match-color" align="backslash-demo" line="0" small-label="backslashes">                                                                </text>

		<text id="" click="10-21" class="bits bits-match-color" align="backslash-demo" line="0" small-label="potential_escape">                                                                </text>

		<text id="ODD_BITS-1" click="8-20" class="bits" align="backslash-demo" line="1" label="ODD_BITS">.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1</text>

		<text id="" click="9-10" class="bits" align="backslash-demo" line="2" small-label="next_is_escaped">0...............................................................</text>

		<text id="maybe_escaped_shr_1" click="11-20" class="bits bits-match-color" align="backslash-demo" line="2" label="maybe_escaped" shr="1">11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11</text>

		<text id="maybe_escaped_2" click="12-20" class="bits bits-match-color" align="backslash-demo" line="3" xsmall-label="maybe_escaped | ODD_BITS" shr="1">111.111.1..1111.1.11111.11111.111111111.11111.1111.1111111111.1</text>

		<text id="" click="13-20" class="bits bits-match-color" align="backslash-demo" line="4" big-label="-" shr="1">11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11</text>

		<text id="even-series" click="14-20" class="bits" align="backslash-demo" line="5" label="even_series">11.1111..1.111.1.11111.1.....1....1....111111.1111.1111111...111
</text>

		<text id="ODD_BITS-2" click="15-20" class="bits" align="backslash-demo" line="6" big-label="^">.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1</text>

		<text id="esc-and-term" click="16-20" class="bits" align="backslash-demo" line="7" label="esc_and_term">1...1.11....1.....1.1....1.1...1.111.1..1.1.111.1...1.1.1..1..1.</text>

		<text id="" click="17-20" class="bits bits-match-color" align="backslash-demo" line="8" big-label="^" shr="1">11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11</text>

		<text id="escaped-bits" click="18-21" class="bits" align="backslash-demo" line="9" label="escaped" shr="1">.1...1.1...1.1.....1.1....1.1...1.1.1.1..1.1.1.1.1.1.1.1.1..1..1</text>

		<rect click="23" x="0" y="230" height="1250" width="22000" style="fill: #100020F8;"/>
		 <g id="backslash-demo2" class="code" click="23" lang="ziggy" x="0" y="230" width="1920" line-height="70" line-num-indent="80" line-indent="245" hide-line-numbers hide-background>
			"abc // 'a'" ++_"\"'//"; // Heya!_\\ G'd'day m8"_[1]u8{'x'}; //s
		</g>

		<text id="slashes" click="24-29" class="bits bit-color-1s-pls" align="backslash-demo2" line="1" label="slashes" shr="1">.....11.............11...11..................................11.</text>

		<text id="slashes_shr_1" click="25-29" class="bits bit-color-1s-pls" align="backslash-demo2" line="2" big-label="&">.....11.............11...11..................................11.</text>

		<text id="double-slash-bits" click="26" class="bits bit-color-1s-pls" align="backslash-demo2" line="3">.....1..............1....1...................................1..</text>

		<text id="double-slash-starts" click="26-28" class="bits bit-color-1s-pls" align="backslash-demo2" line="3" ysmall-label="double_slash_starts">                                                                </text>

		<text id="double-slash-comment_bounds_incl_carry" click="28" class="bits bit-color-1s-pls" align="backslash-demo2" line="3" xsmall-label="comment_bounds_incl_carry">                                                                </text>


		<text id="double-backslash" click="27" class="bits bit-color-1s-pls" align="backslash-demo2" line="4">..................................1.............................</text>

		<text id="" click="27-29" class="bits bit-color-1s-pls" align="backslash-demo2" line="4" xsmall-label="double_backslash_starts">                                                                </text>
		<text id="" click="29" class="bits bit-color-1s-pls" align="backslash-demo2" line="4" xsmall-label="line_str_bnds_incl_carry">                                                                </text>

		<text id="" click="30" class="bits bit-color-1s-pls" align="backslash-demo2" line="1" xsmall-label="quote_bnds_incl_carry">1..........1....1.....1........................1................</text>

		<text id="" click="31" class="bits bit-color-1s-pls" align="backslash-demo2" line="2" xsmall-label="apostr_bnds_incl_carry">........1.1........1..................1.1..............1.1......</text>

		<text id="" click="35" class="bits bit-color-1s-pls" align="backslash-demo2" line="5" xsmall-label="all_bnds_incl_carry">1....1.....1....1...1.1..1........1............1.............1..</text>
		<text id="" click="36" class="bits bit-color-1s-pls" align="backslash-demo2" line="6" xsmall-label="cars_or_nls_or_eof">...............1.................1..............1...............</text>
		<text id="" click="37" class="bits bit-color-1s-pls" align="backslash-demo2" line="7" xsmall-label="">1...............1.................1..............1..............</text>
		<text id="" click="37-38" class="bits bit-color-1s-pls" align="backslash-demo2" line="7" xsmall-label="(cars_or_nls_or_eof << 1)|1">                                                                </text>
		<text id="" click="38" class="bits bit-color-1s-pls" align="backslash-demo2" line="7" label="iter">                                                                </text>
		<text id="" click="39" class="bits bit-color-1s-pls" align="backslash-demo2" line="8" xsmall-label="cars_or_nls|all_bnds_incl_carry">
			1....1.....1...11...1.1..1.......11............11............1..</text>

		<text id="" click="40" class="bits bit-color-1s-pls" align="backslash-demo2" line="9" xsmall-label="sub">
		.....1.....1...1....1.1..1.......1.............11111111111111...</text>

		<text id="" click="41" class="bits bit-color-1s-pls" align="backslash-demo2" line="10" xsmall-label="starts">
		1...............1.................1..........................1..</text>

		<text id="" click="42-44" class="bits bit-color-1s-pls" align="backslash-demo2" line="11" xsmall-label="interleaved">
		...............1.................1..............1...............</text>

		<text id="" click="44-47" class="bits bit-color-1s-pls" align="backslash-demo2" line="11" xsmall-label="interleaved">1..........1...11.....1..........1..............1...............
		</text>

		<text id="" click="47" class="bits bit-color-1s-pls" align="backslash-demo2" line="11" xsmall-label="interleaved">
			...........1...1......1..........1..............1...............
		</text>

		<text id="" click="48" class="bits bit-color-1s-pls" align="backslash-demo2" line="12" xsmall-label="cur_ends">
			...........1..........1.........................1...............
		</text>

		<style>
			html {
				scrollbar-color: white black;
			}
		</style>

		<script>

		function shr_by_1({ id, no_enter = false }) {
			const obj = document.getElementById(id);
			// const click = obj.getAttribute("click")
			const objects = [...obj.getElementsByTagName("tspan")];
			const [xobj] = objects;
			const last_object = objects.pop();
			const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
			tspan.setAttribute("class", "code-color-7" + (no_enter ? "" : " enter-bb"));
			tspan.textContent = "0";
			xobj.parentNode.insertBefore(tspan, xobj);
			last_object.classList.add("leave-bb")
		}

		function shl_by_1({ id, no_enter = false }) {
			const obj = document.getElementById(id);
			// const click = obj.getAttribute("click")
			const objects = [...obj.getElementsByTagName("tspan")];
			const xobj = objects.pop();
			const last_object = objects.shift();
			const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
			tspan.setAttribute("class", "code-color-7" + (no_enter ? "" : " enter-bb"));
			tspan.textContent = "0";
			xobj.parentNode.insertBefore(tspan, xobj);
			last_object.classList.add("leave-bb")
		}

		let shifted_left = 0;

		function shl_by_1_raw({ id, no_enter = false }) {
			const obj = document.getElementById(id);
			const click = obj.getAttribute("click")
			obj.innerHTML = obj.innerHTML.replace(/^([1.])([1.]{63})$/g, (e, a, b) => `&lt;tspan id="exiting-${shifted_left}" class="code-color-7"&gt;${a}&lt;/tspan&gt;${b}.`)
			global_animations.push({
			section: "phase-2a-stuff-overlay",
				selector: `#exiting-${shifted_left}`,
				slide_num: click,
				animation_duration: "2s",
				continuous: true,
				keyframes: {
					0:   { "letter-spacing": "-6px", opacity: 1 },
					80:  { opacity: 0 },
				100: { "letter-spacing": "-32px", opacity: 0 },
				}
			});
			shifted_left++;

			<!-- const objects = [...obj.getElementsByTagName("tspan")];
			const xobj = objects.pop();
			const last_object = objects.shift();
			const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
			tspan.setAttribute("class", "code-color-7" + (no_enter ? "" : " enter-bb"));
			tspan.textContent = "0";
			xobj.parentNode.insertBefore(tspan, xobj);
			last_object.classList.add("leave-bb") -->
		}

		function color_odd_bits({ id, c = 3 }) {
			const obj = document.getElementById(id);
			obj.innerHTML = obj.innerHTML.replaceAll(/1/g, `&lt;tspan class="code-color-${c}"&gt;1&lt;/tspan&gt;`)
		}

		for (const obj of document.getElementsByClassName("bit-color-1s-pls")) {
			obj.innerHTML = obj.innerHTML.replaceAll(/1/g, `&lt;tspan class="code-color-${4}"&gt;1&lt;/tspan&gt;`)
		}

		post_processes.push(() => {
			shr_by_1({ id: "maybe_escaped_shr_1" });
			shr_by_1({ id: "maybe_escaped_2", no_enter: true });
			color_odd_bits({ id: "ODD_BITS-1" });
			color_odd_bits({ id: "ODD_BITS-2" });
			color_odd_bits({ id: "even-series", c: 4 });
			color_odd_bits({ id: "esc-and-term", c: 2 });
			color_odd_bits({ id: "escaped-bits", c: 1 });
			shl_by_1_raw({ id: "slashes_shr_1" });

			const maybe_escaped_2 = document.getElementById("maybe_escaped_2");
			maybe_escaped_2.innerHTML = maybe_escaped_2.innerHTML.replaceAll(`&lt;tspan class="code-color-white"&gt;1&lt;/tspan&gt;`, `&lt;tspan class="code-color-3"&gt;1&lt;/tspan&gt;`)

		});

		global_animations.push({
			section: "phase-2a-stuff-overlay",
			selector: ".enter-bb",
			slide_num: 11,
			animation_duration: "2s",
			continuous: true,
			keyframes: {
					0:   { "letter-spacing": "-32px", opacity: 0 },
					80:  { opacity: 1 },
				100: { "letter-spacing": "-6px", opacity: 1 },
			}
		}, {
			section: "phase-2a-stuff-overlay",
			selector: ".leave-bb",
			slide_num: 11,
			animation_duration: "2s",
			continuous: true,
			keyframes: {
					0:   { "letter-spacing": "-6px", opacity: 1 },
					80:  { opacity: 0 },
				100: { "letter-spacing": "-32px", opacity: 0 },
			}
		}, {
			section: "phase-2a-stuff-overlay",
			selector: "#escaped-bits, #escaped-bits-label",
			slide_num: 20,
			animation_duration: "2s",
			continuous: true,
			keyframes: {
					0:   {	transform: "translateY(0)" },
					100: { transform: "translateY(-560px)" },
			}
		}, {
			section: "phase-2a-stuff-overlay",
			selector: "#escaped-bits, #escaped-bits-label",
			slide_num: 21,
			animation_duration: "1s",
			continuous: true,
			keyframes: {
					0:   {	transform: "translateY(-560px)", opacity: 1 },
					100: { transform: "translateY(-630px)", opacity: 0 },
			}
		});
	</script>

		<!-- <text id="" click="10" class="bits bits-match-color" align="backslash-demo" line="3" small-label="potential_escape">11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11</text> -->
	</g>
</svg>

<style>
	#button-left, #button-right {
		position: fixed;
		font-size: 2rem;
		font-family: 'Press Start 2P';
		bottom: 1rem;
		color: white;
		text-align: center;
		align-content: center;
		height: 1.5rem;
		width: 4rem;
		padding: 0.5rem 0.85rem;
		background: none;
		border: none;
	}

	#button-left {
		left: 0rem;
	}

	#button-right {
		right: 0rem;
	}

	.code-star {
		alignment-baseline: middle;
	}

	.code-color-white { fill: #fff; }
	.code-color-0 { fill: rgb(80, 250, 123); }
	.code-color-1 { fill: #60f4d4; }
	.code-color-2 { fill: rgb(189, 147, 249); }
	.code-color-3 { fill: rgb(255, 121, 198); }
	.code-color-4 { fill: rgb(255, 184, 104); }
	.code-color-5 { fill: #F1FA8C; }
	.code-color-6 { fill: #7960f4; }
	.code-color-7 { fill: #f46060; }
	/* .code-color-8 { fill: #60f4d4; } */

	.code-block-label {
		text-decoration: underline;
		fill: rgb(80, 250, 123);
	}

	.code-builtin {
		fill: rgb(139, 233, 253);
	}

	.code-num {
		fill: rgb(189, 147, 249);
	}

	.code-type, .code-keyword, .code-symbol-1  {
		fill: rgb(255, 121, 198);
	}

	.code-struct-type {
		fill: rgb(255, 184, 104);
		font-style: italic;
	}

	.code-register {
		fill: #b6c8ff;
	}

	.code-comment {
		font-style: normal;
		fill: #6272a4;
	}

	.code-type {
		font-style: italic;
	}

	.code-string {
		fill: #F1FA8C;
	}

	.code-space {
		fill: rgb(98, 114, 164);
	}

	.bit-1 {
		fill: #F1FA8C;
	}

	.line-of-code, .line-number, .bits, .label, .small-label, .xsmall-label, .ysmall-label, .big-label {
		font-family: 'Iosevka', 'Press Start 2P', 'Courier New', Courier, monospace;
		font-size: 64px;
		letter-spacing: -6px;
		fill: rgb(248, 248, 242)
	}

	.bits, .bits .code-type {
		font-style: normal;
	}

	.line-number {
		font-size: 45px;
	}

	.label {
		font-size: 40px;
		baseline-shift: 10px;
		letter-spacing: -4px;
	}

	.small-label {
		font-size: 28px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.xsmall-label {
		font-size: 20px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.ysmall-label {
		font-size: 25px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.big-label {
		font-size: 70px;
	}

	.code-func-name {
		fill: rgb(80, 250, 123);
	}

	.code-instruction {
		fill: rgb(255, 121, 198);
	}

	.code-keyword-asm {
		fill: rgb(255, 184, 104);
	}

	.code-curly-0 { fill: rgb(248, 248, 242); }
	.code-curly-1 { fill: rgb(255, 121, 198); }
	.code-curly-2 { fill: rgb(139, 233, 253); }
	.code-curly-3 { fill: rgb(80, 250, 123); }
	.code-curly-4 { fill: rgb(189, 147, 249); }
	.code-curly-5 { fill: rgb(255, 184, 104); }
	.code-paren-0 { fill: rgb(248, 248, 242); }
	.code-paren-1 { fill: #F1FA8C; }
	.code-paren-2 { fill: rgb(255, 184, 104); }
	.code-paren-3 { fill: rgb(255, 121, 198); }
 	.code-paren-4 { fill: rgb(189, 147, 249); }
 	.code-paren-5 { fill: rgb(139, 233, 253); }

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Bold-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Bold-Italic.woff') format('woff');
		font-weight: 700;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Bold.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Bold.woff') format('woff');
		font-weight: 700;
		font-style: normal;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold-Italic.woff') format('woff');
		font-weight: 800;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold.woff') format('woff');
		font-weight: 800;
		font-style: normal;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Italic.woff') format('woff');
		font-weight: 400;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Medium-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Medium-Italic.woff') format('woff');
		font-weight: 500;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Medium.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Medium.woff') format('woff');
		font-weight: 500;
		font-style: normal;
		font-display: swap;
	}
	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Regular.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Regular.woff') format('woff');
		font-weight: 400;
		font-style: normal;
		font-display: swap;
	}
</style>

<button id="button-left" onclick="goBackward()">&lt;</button>
<button id="button-right" onclick="goForward()">&gt;</button>

<script>
	const code_snippets = new Map();
	code_snippets.set("title", "Intro to SIMD in Zig\nby Niles Salter (@Validark)");

	function processRanges(ranges, joined_lines) {
		return ranges
			.reduce((a, [n, start, end]) =>
				`${a.slice(0, start)}<tspan class="code-${n}">${a.slice(start, end).replaceAll(/ +/g, e => "&nbsp;".repeat(e.length))}</tspan>${a.slice(end)}`,
				joined_lines.replaceAll("&gt;", ">").replaceAll("&lt;", "<")
			)
			.split('\n');
	}

	function preprocess(slide_id, text, lang) {
		let start_pos = text.indexOf("\n");
		let end_pos = text.lastIndexOf("\n");

		if (text.slice(0, start_pos + 1).trim() !== "")
			start_pos = -1;

		if (text.slice(end_pos, -1).trim() !== "")
			end_pos = -1

		let lines = text.slice(start_pos + 1, end_pos).split('\n').map(e => e.trimRight().replaceAll('\t', '    '));
		const unnecessary_whitespace = lines.filter(e => e).reduce((a, c) => Math.min(a, c.length - c.trimLeft().length), Number.POSITIVE_INFINITY);
		lines = lines.map(e => e.slice(unnecessary_whitespace));
		code_snippets.set(slide_id, (code_snippets.get(slide_id) || "") + lines.join("\n"));
		let curly_depth = 0;
		let paren_depth = 0;

		const joined_lines = lines.join('\n').replaceAll("&gt;", ">").replaceAll("&lt;", "<").replaceAll(" => ", " &rArr; ").replaceAll(" != ", " &ne; ")
			.replaceAll(" == ", " &Equal; ");

		const ranges = new Array();

		// for (; )
		// for (let regex = /".+?"/g, cur = regex.exec(joined_lines); cur; cur = regex.exec(joined_lines));

		// const meme = RegExp.prototype.exec.bind(/".+?"/g, joined_lines);
		// joined_lines;

		const in_match = new Array(joined_lines.length).fill(false);

		if (lang === 'zig' || lang === 'ziggy') {
			// console.log(joined_lines);

			// let pos = 0;
			for (const match of joined_lines.matchAll(lang === "ziggy" ? /\/\/([^_]*|$)|"[^_]*?(?<!\\)"|'[^_]*?'|\\\\([^_]*|$)/g : /\/\/([^\n]*|$)|"[^\n]*?(?<!\\)"|'[^\n]*?'|\\\\([^\n]*|$)/g)) {
				const { index, 0: { length } } = match;
				for (let q = 0; q < length; q++) in_match[index + q] = true;
				ranges.push([match[0][0] === '/' ? "comment" : "string", index, index + length]);
			}



			// for (const [regex, name] of [
			// 	[/\/\/([^\n]*|$)/g, "comment"],
			// 	[/"[^\n]*?"|'[^\n]*?'/g, "string"],
			// ]) {
			// 	outer: for (const { index, 0: s } of joined_lines.matchAll(regex)) {
			// 		const { length } = s;
			// 		// console.log({index, length, s})
			// 		for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
			// 		for (let q = 0; q < length; q++) in_match[index + q] = true;
			// 		ranges.push([name, index, index + length]);
			// 	}
			// }

			for (const [regex, name] of [
				[/(?<!\w)(usingnamespace|linksection|threadlocal|unreachable|addrspace|allowzero|nosuspend|anyframe|callconv|comptime|continue|errdefer|noinline|volatile|anytype|noalias|suspend|export|undefined|extern|inline|opaque|orelse|packed|false|true|resume|return|struct|switch|align|async|await|break|catch|const|defer|error|union|while|else|enum|test|and|asm|for|pub|try|var|fn|if|or)(?!\w)/g, "keyword"],
				[/(?<!\w)(Carry)(?!\w)/g, "struct-type"],
				[/@\w+/g, "builtin"],
				[/ +/g, "space"],
				[/(?:&rArr;)|(?:&amp;)|(?:&ne;)|(?:&Equal;)|[*:=><!+~|^-]/g, "symbol-1"],
				[/\w+(?=\()|(?<=fn )\w+/g, "func-name"],
				[/(?<!\w)(?:[ui]\d+|void|bool|uint)/g, "type"],
				[/(?<!\w)0x[\dA-Fa-f]+/g, "num"],
				[/(?<!\w)(?:0[b])?\d+/g, "num"],
				[/\*/g, "star"],
			]) {
				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}
		} else if (lang === "asm") {
			for (const [regex, name] of [
				[/"[^\n]+?"|'[^\n]+?'/g, "string"],
				[/;([^\n]+|$)/g, "comment"],
			]) {
				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}

			for (const [regex, name] of [
				[/ +/g, "space"],
				[/\*/g, "star"],
				[/(?<!\w)(?:[re]?[abcd]x|[abcd][hl]|[er]?[sb]p|[er]?[ds]i|r[89]|r1[0-5][bwd]?|[xyz]mm[0-9]|zmm[12][0-9]|[xy]mm1[0-5]|zmm3[01]|rip)(?!\w)/g, "register"],
				// [/[:=]/g, "symbol-1"],
				[/.LBB\d+_\d+/g, "block-label"],
				[/(?<!\w)-?\d+/g, "num"],
				[/(?<=call +)[_.\w]+/g, "func-name"],
				[/(?<=\+ )[_.\w]+/g, "func-name"],
				[/(?<=^|\n)[_.\w]+:/g, "func-name"],
				[/(?<!\w)(qword|ptr|dword|byte|word|xmmword|ymmword|zmmword)(?!\w)/g, "keyword-asm"],
				[/(?<=^[ \t]*|\n[ \t]*)\.?\w+/g, "instruction"],
				]) {
					if (name === "instruction") {
						for (const x of joined_lines.matchAll(regex)) {
							const { index, 0: { length } } = x;
							// console.log(index, length, x);
						}
					}

				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					if (length === 0) throw new Error("bad news");
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}
		} if (lang === "rainbow") {
			let cur_color = 0;
			for (let i = 0; i < joined_lines.length; ) {
				for (; i < joined_lines.length && joined_lines[i] !== '1'; i++) {
					ranges.push([`color-white`, i, i + 1]);
				}
				for (; i < joined_lines.length && joined_lines[i] === '1'; i++) {
					ranges.push([`color-${5}`, i, i + 1]);
				}
				cur_color += 1;
			}
		}


		// .replaceAll(//g, (_, pre, e) => `${pre}<tspan class="code-func-name">${e}</tspan>`)

		for (const [regex, name, [opener, closer]] of [
			[/[{}]/g, "curly", "{}"],
			[/[()]/g, "paren", "()"],
		]) {
			outer: for (const { index, 0: { 0: e, length } } of joined_lines.matchAll(regex)) {
				for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
				for (let q = 0; q < length; q++) in_match[index + q] = true;
				if (e === closer) {
					curly_depth--;
				}

				ranges.push([`${name}-${curly_depth % 6}`, index, index + length]);

				if (e === opener) {
					curly_depth++;
				}
			}
		}

		return [
			processRanges(ranges.sort(([, a], [, b]) => b - a), joined_lines),
			ranges
		];
	}

	const container = document.getElementById("container");
	const overlay = document.getElementById("overlay");
	const slide_elements = [...container.children];
	const overlay_elements = slide_elements.map(e => document.getElementById(e.id + "-overlay") || (() => {
		// console.log(e);
		overlay.insertAdjacentHTML("beforeend", `<g class="slide" id="${e.id}-overlay"></g>`)
		return document.getElementById(`${e.id}-overlay`);
	})());

	const EmptyFunction = () => {};

	const clicks = new Map();
	const slidesById = new Map();
	const pane_heights = new Map();

	function recursivelyHandleChildren(child_state_transitions, child, current_click_num) {
		for (const grandchild of child.children) {
			let click_attr = grandchild.getAttribute("click")
			if (click_attr !== null) {
				grandchild.setAttribute("hidden", "");
				const [click, click2] = click_attr.split('-');
				const clicky = (click === "") ? ++current_click_num : parseInt(click) || 1;

				const unhide_slide = () => {
					// setTimeout(() => grandchild.removeAttribute("hidden"), 1000);
					grandchild.classList.remove("hide-slide");
					grandchild.classList.add("unhide-slide");
					grandchild.removeAttribute("hidden");
				};

				const hide_slide = () => {
					// console.log("hiding", grandchild);
					grandchild.classList.remove("unhide-slide");
					grandchild.classList.add("hide-slide");
					// setTimeout(() => {
					// 	if (+cur_click > (+click2 || -Infinity) || +click < +cur_click)
					// 		grandchild.setAttribute("hidden", "");
					// }, 1000);
				};

				child_state_transitions[clicky].push(unhide_slide);
				child_state_transitions[clicky - 1].push(hide_slide);

				if (click2) {
					child_state_transitions[click2].push(hide_slide);
					child_state_transitions[click2 - 1].push(unhide_slide);
				}
			}
			current_click_num = recursivelyHandleChildren(child_state_transitions, grandchild, current_click_num);
		}

		return current_click_num;
	}

	function countClicks(child, state) {
		for (const grandchild of child.children) {
			let click = grandchild.getAttribute("click")
			if (click !== null) {
				grandchild.setAttribute("hidden", "");
				const clicky = (click === "") ? ++state.current_click_num : parseInt(click) || 1;
				if (clicky > state.max_click_num) state.max_click_num = clicky;
			}
			countClicks(grandchild, state);
		}
		return state;
	}

	post_processes.push(() => {
		for (const [is_overlay, elements] of  [[false, slide_elements], [true, overlay_elements]]) {
			for (const [i, child] of elements.entries()) {
				child.setAttribute("hidden", "");
				const id = child.getAttribute("id");
				if (id === null) throw new Error("Please add an ID to slide " + i + ` (after the slide with an id of "${elements[i - 1].id}")`);
				const id_without_overlay = id.replace("-overlay", "");
				const click_attr = child.getAttribute("clicks");
				const num_clicks = is_overlay ? clicks.get(id_without_overlay) : parseInt(click_attr?.split(",").length > 1 ? click_attr.split(",").length + 1 : click_attr) ||
					(1 + countClicks(child, { current_click_num: 0, max_click_num: 0 }).max_click_num);

				clicks.set(id_without_overlay, num_clicks);
				const arr = slidesById.get(id_without_overlay) || [];
				arr.push(child);
				slidesById.set(id_without_overlay, arr);

				const child_state_transitions = is_overlay ? state_transitions.get(id_without_overlay) : new Array(num_clicks).fill(0).map(() => []);
				if (!is_overlay) state_transitions.set(id, child_state_transitions);

				child_state_transitions[0].push(() => {
					child.removeAttribute("hidden")
					if (i > 0) elements[i - 1].setAttribute("hidden", "")
					if (i < elements.length - 1) elements[i + 1].setAttribute("hidden", "")
					if (!is_overlay)
						container.setAttribute("viewBox", `0 0 1920 ${pane_heights.get(id) || 1080}`);
				});

				child_state_transitions[num_clicks - 1].push(() => {
					child.removeAttribute("hidden")
					if (i > 0) elements[i - 1].setAttribute("hidden", "")
					if (i < elements.length - 1) elements[i + 1].setAttribute("hidden", "")
				});

				// if (is_overlay)
				// 	state_transitions.get(id_without_overlay).forEach((a, i) => {
				// 		child_state_transitions.forEach((b, j) => {
				// 			console.log(a);
				// 			a.push(b);
				// 		});
				// 	});

				recursivelyHandleChildren(child_state_transitions, child, 0)
			}
		}
	});

				// 	global_scrolls.push({
				// 	section: slide_id,
				// 	slide_num: i + 1,
				// 	animation_duration,
				// 	pos: next,
				// });

	post_processes.push(() => {
		/**
		 * Create a cubic-bezier easing function.
		 * @param {number} p0x
		 * @param {number} p0y
		 * @param {number} p1x
		 * @param {number} p1y
		 */
		function cubicBezier(p0x, p0y, p1x, p1y) {
		// Helper functions for bezier math
		function cubic(a, b, m) { return ((1 - 3*b + 3*a) * m ** 3) + ((3*b - 6*a) * m ** 2) + (3*a * m); }
		function cubicDerivative(a, b, m) { return (3*(1 - 3*b + 3*a) * m ** 2) + (2*(3*b - 6*a) * m) + (3*a); }

		return function(t) {
			// Newton-Raphson iteration to find the parametric value for time t
			let x = t, i = 0;
			for (; i < 5; i++) {
			const xEstimate = cubic(p0x, p1x, x) - t;
			const dx = cubicDerivative(p0x, p1x, x);
			if (Math.abs(xEstimate) < 1e-6) break;
			x -= xEstimate / dx;
			}
			return cubic(p0y, p1y, x);
		};
		}

		// Your easing curve: cubic-bezier(0.69, 0.02, 0.53, 1)
		const easeCustom = cubicBezier(0.69, 0.02, 0.53, 1);

		/**
		 * Smooth scroll to target using cubic-bezier easing.
		 */
		function scrollToPosition(targetY, duration = 500) {
			const startY = window.scrollY;
			const distance = targetY - startY;
			let startTime = null;

			function step(timestamp) {
				if (!startTime) startTime = timestamp;
				const elapsed = timestamp - startTime;
				const progress = Math.min(elapsed / duration, 1);

				const easedProgress = easeCustom(progress);

				if (elapsed < duration) {
					window.scrollTo(0, startY + distance * easedProgress);
					requestAnimationFrame(step);
				} else {
					window.scrollTo(0, targetY);
				}
			}

			requestAnimationFrame(step);
		}

		function scrollElementOffsetAnimated(elem, offsetPx, duration = 500) {
			let startTime = null;

			function step(timestamp) {
				const rect = elem.getBoundingClientRect();
				const startY = window.scrollY;
				const targetY = startY + rect.top - offsetPx;
				const distance = targetY - startY;
				if (!startTime) startTime = timestamp;
				const elapsed = timestamp - startTime;
				window.scrollTo(0, startY + distance);
				if (elapsed < duration) requestAnimationFrame(step);
			}

			requestAnimationFrame(step);
		}


		{
			let i = 0;
			for (const { section, slide_num, animation_duration, selector } of global_scrolls) {
				state_transitions.get(section)[slide_num].push(() => {
					const elem = document.querySelector(selector);
					const styles = getComputedStyle(elem);

					// console.log({elem, animation_duration: styles.animationDuration})

					// console.log(styles.animationName);       // e.g., "fadeIn"
					// console.log();   // e.g., "2s"
					// console.log(styles.animationDelay);      // e.g., "0.5s"
					// console.log(styles.animationIterationCount); // e.g., "infinite"
					// console.log('');
					scrollElementOffsetAnimated(document.querySelector(selector),
						// offset from top
						50,
						1000 * styles.animationDuration.slice(0, -1));
				});
				post_processes.push(() => {
					scrollElementOffsetAnimated(document.querySelector(selector),
								// offset from top
								50,
								1500);
				});
			}


		}

		// console.log(global_scrolls);
	})

	const code_info = new Map();

	let code_block_i = 0;

	for (const codeblock of document.getElementsByClassName("code")) {
		let codeblock_id = codeblock.getAttribute("id");
		const x = +codeblock.getAttribute("x");
		const y = +codeblock.getAttribute("y");
		const steps = codeblock.getAttribute("steps");
		const lang = codeblock.getAttribute("lang");
		const width = +codeblock.getAttribute("width");
		if (codeblock.getAttribute("height")) {
			throw new Error("Height is not allowed on code block")
		}
		const line_height = +codeblock.getAttribute("line-height");
		const font_size = codeblock.getAttribute("font-size");
		const line_num_indent = +codeblock.getAttribute("line-num-indent");
		const hide_line_numbers = codeblock.hasAttribute("hide-line-numbers");

		const line_indent = +codeblock.getAttribute("line-indent");
		let slide = codeblock;
		do slide = slide.parentNode; while (!slide.classList.contains("slide"));
		const slide_id = slide.getAttribute("id");


		const [lines, ranges] = preprocess(slide_id, codeblock.innerHTML, lang);

		if (codeblock_id) {
			code_info.set(codeblock_id, { x, y, width, line_height, line_num_indent, hide_line_numbers, line_indent, slide, ranges });
		} else {
			codeblock_id = `codeblock-${code_block_i++}`;
			codeblock.setAttribute("id", codeblock_id);
		}

		if (lines.length > 0) {
			let innerHTML = codeblock.hasAttribute("hide-background") ? '' : `<rect x="${x || 0}" y="${y || 0}" height="${y + (line_height*(codeblock.getAttribute("lines") || lines.length)) + 20}" width="${width}" fill="black"></rect>`;
			innerHTML += lines.map((e, i) => `<text class="line-of-code" x="${x + line_indent}" y="${y + (line_height*(i+1))}">${e}</text>`).join('\n');

			if (!hide_line_numbers)
				innerHTML += lines.map((_, i) => `<text class="line-number" x="${x + line_num_indent}" y="${y + (line_height*(i+1)) - 1}" text-anchor="end">${i + 1}</text>`);

			const extra_height = y + (line_height*(lines.length));

			if (extra_height > 1080) {
				pane_heights.set(slide_id, extra_height);

				for (const body of document.getElementsByTagName("body")) {
					body.insertAdjacentHTML("beforeend",
`
<style>
#container[slide="${slide_id}"] {
	height: ${extra_height / 10.80}%
}
</style>
`);
				}
		}

			codeblock.innerHTML = innerHTML;
		}

		if (steps) {
			codeblock.insertAdjacentHTML("afterbegin", `<rect id="${codeblock_id}-rect" width="1950" fill="purple"></rect>`)
			let last = 0;
			let last_height = 0;
			let last_y = 0;
			var colors = ["rgb(99, 81, 1)", "purple", "rgb(99, 0, 0)", "rgb(88, 0, 128)", "rgb(0, 0, 128)"];
			Array.prototype.push.apply(global_animations, steps.split(",").map((av, i, k) => {
				const isLast = k.length === i + 1;
				let [v, num_lines] = av.split(":");
				num_lines ||= '1';
				const prev = last;

				// (8 - num_lines)
				// 2076



				const next = last = Math.min(0, (-v + Math.max(2, 3 - num_lines)) * line_height) - 9;
				const animation_duration = `${2.5*Math.max(0.2, Math.abs(next - prev) / 10000)}s`;
				// console.log({ prev, next, animation_duration });
				// console.log([v, y + (line_height*(v - 1)) + 10]);

				const prev_height = last_height;
				const next_height = last_height = `${line_height*(num_lines || 1) + line_height / 7}px`;

				const prev_y = last_y;
				const next_y = last_y = `${y + (line_height*(v - 1)) + line_height / 7}px`;

				global_scrolls.push({
					section: slide_id,
					slide_num: i + 1,
					animation_duration,
					// pos: next,
					selector: `#${codeblock_id}-rect`,
				});

				return [

				// {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i + 1,
				// 	forward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${prev}px)` },
				// 		100: { transform: `translateY(${next}px)` },
				// 	}
				// }, {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i,
				// 	backward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${next}px)` },
				// 		100: { transform: `translateY(${prev}px)` },
				// 	}
				// },
				{
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i + 1,
					forward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: prev_height, y: prev_y, fill: colors[(i + 0) % colors.length] },
						100: { height: next_height, y: next_y, fill: colors[(i + 1) % colors.length] },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: next_height, y: next_y, fill: colors[(i + 1) % colors.length] },
						100: { height: prev_height, y: prev_y, fill: colors[(i + 0) % colors.length] },
					}
				}, isLast && {
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i + 1,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: next_height, y: next_y },
						100: { height: next_height, y: next_y },
					}
				},
				// isLast && {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i + 1,
				// 	backward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${next}px)` },
				// 		100: { transform: `translateY(${next}px)` },
				// 	}
				// }
			];
			}).flat())
		}
	}

	for (const text of [...document.getElementsByTagName("text")]) {
		const align = text.getAttribute("align");
		if (align) {
			const line = +text.getAttribute("line");
			const info = code_info.get(align);

			text.setAttribute("x", info.x + info.line_indent);
			text.setAttribute("y", info.y + (info.line_height*(line+1)));

			for (const cl of ["label", "small-label", "xsmall-label", "ysmall-label", "big-label"]) {
				const label = text.getAttribute(cl);

				if (label) {
					const click = text.getAttribute("click");
					text.insertAdjacentHTML("beforebegin", `<text id="${text.getAttribute("id")}-label" class="${cl}" ${click ? `click=${click}` : ""} text-anchor="end" x="${info.x + info.line_indent}" y="${info.y + (info.line_height*(line+1))}">${label.replaceAll(">>", "»").replaceAll("<<", "«")}${label.length === 1 ? '' : `:`}&nbsp;</text>`)
				}
			}
		}
	}

	for (const bits of document.getElementsByClassName("bits-auto-color")) {
		bits.innerHTML = bits.innerHTML.replaceAll(/1+/g, e => `<tspan class="bit-1">${e}</tspan>`);
	}

	// const indexToChar = new Array(64).fill('').map((_, i) => i < 62 ? i < 36 ? i.toString(36) : (i - 26).toString(36).toUpperCase() : '&$'[i - 62]);


	for (const bits of document.getElementsByClassName("bits-match-color")) {
		const align = bits.getAttribute("align");
		if (!align) throw new Error("bits-match-color must use the 'align' property to be paired up with something!")
		const info = code_info.get(align);
		// console.log(bits.innerHTML);
		bits.innerHTML = processRanges(info.ranges, bits.innerHTML).join('\n');
	}

	{
		let i = 0;
		for (const bits of document.getElementsByClassName("bits-match-color2")) {
			const align = bits.getAttribute("align");
			if (!align) throw new Error("bits-match-color2 must use the 'align' property to be paired up with something!")
			const info = code_info.get(align);

			const [smally] = bits.getElementsByClassName("bits-small")

			for (const [kind, bottom, top] of info.ranges) {
				if (bottom <= i && i < top) {
					smally.classList.add("code-" + kind);
					break;
				}
			}
			// bits.innerHTML = processRanges(info.ranges, bits.innerHTML).join('\n');
			i++;
		}
	}

	for (const post_process of post_processes) post_process();

	const all_styles = new Map();

{
	let i = 0;
	let styles = new Array();
	let prev_selector;
	let prev_slide_num;
	let prev_section;
	const animations = new Array();

	function getSelectorForInternal(ge, num_clicks) {
		if (ge === num_clicks) throw new Error("num_clicks must be higher than the target click (clicks start at 0)")
		let arr = [];
		let y = ge;
		for (; y % 10; y++) {
			if (y >= num_clicks) return arr;
			arr.push(`[click="${y}"]`);
		}

		let z = y;
		let i = -1;
		for (; z % 100; z += 10) {
			if (z >= num_clicks) return arr;
			if (z / 10 === ge) {
				for (; z % 100; z += 10) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 10}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			arr.push(`[click^="${z / 10}"]:not([click="${z / 10}"])`);
		}

		let q = z;
		i = -1;
		for (; z % 1000; z += 100) {
			if (z >= num_clicks) return arr;
			// console.log(z, ge)
			if (z / 100 === ge) {
				for (; z % 1000; z += 100) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 100}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			for (let j = 0; j < 10; j++) {
				const k = z / 10 + j;

				arr.push(`[click^="${k}"]${ge <= k && k < num_clicks ? '' : `:not([click="${k}"])`}`);
			}
		}

		return arr;
	}

	function getSelectorFor(ge, num_clicks) {
		return `:is(${getSelectorForInternal(+ge, +num_clicks).join(", ")})`;
	}

	function getSelectorForRangeInternal(num_clicks, ge, lt) {
		if (ge === num_clicks) throw new Error("num_clicks must be higher than the target click (clicks start at 0)")
		let arr = [];
		let y = ge;
		for (; y % 10; y++) {
			if (y >= num_clicks) return arr;
			arr.push(`[click="${y}"]`);
		}

		let z = y;
		let i = -1;
		for (; z % 100; z += 10) {
			if (z >= num_clicks) return arr;
			if (z / 10 === ge) {
				for (; z % 100; z += 10) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 10}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			arr.push(`[click^="${z / 10}"]:not([click="${z / 10}"])`);
		}

		let q = z;
		i = -1;
		for (; z % 1000; z += 100) {
			if (z >= num_clicks) return arr;
			// console.log(z, ge)
			if (z / 100 === ge) {
				for (; z % 1000; z += 100) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 100}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			for (let j = 0; j < 10; j++) {
				const k = z / 10 + j;

				arr.push(`[click^="${k}"]${ge <= k && k < num_clicks ? '' : `:not([click="${k}"])`}`);
			}
		}

		return arr;
	}

	function getSelectorForRange(num_clicks, ge, lt) {
		return `:is(${getSelectorForRangeInternal(+num_clicks, +ge, +lt).join(", ")})`;
	}

	// console.log(getSelectorFor('5', '23'));
	// console.log(getSelectorFor('23', '33'));
	// console.log(getSelectorFor('20', '30'));

	const elements_to_selectors = new Map();
	const selectors_to_keyframes = new Map();

	for (const { section = (() => { throw "Invalid section" })(), selector, slide_num, keyframes } of global_animations.filter(e => e)) {
		const start_keyframe = keyframes[0];
		const end_keyframe = keyframes[100];

		for (const [, individual_selector] of selector.matchAll(/([^,]+?)(?:, ?|$)/g)) {
			for (const element of document.querySelectorAll(individual_selector)) {
				const old = elements_to_selectors.get(element);
				if (old && old !== individual_selector) {
					throw new Error("Cannot make an object peacefully coexist in two different classes/ids. Please use id's instead. Conflict between `" + individual_selector + "` and `" + old + "`");
				} else {
					elements_to_selectors.set(element, individual_selector);
				}
			}

			let arr = selectors_to_keyframes.get(individual_selector);
			if (arr === undefined) {
				arr = new Array();
				selectors_to_keyframes.set(individual_selector, arr);
			}
			arr.push({ slide_num, start_keyframe, end_keyframe });
		}
	}

	for (const [i, v] of selectors_to_keyframes.entries()) {
		let prev_slide_num = 0;

		for (const { slide_num, start_keyframe, end_keyframe } of v.sort((a, b) => a.slide_num - b.slide_num)) {
			// prev_slide_num, slide_num, new Array(slide_num - prev_slide_num).fill().map((_, i) => i + prev_slide_num);
			console.log(slide_num, prev_slide_num);
			prev_slide_num = slide_num;
		}
	}

	//
	for (const { section, selector, slide_num, keyframes, animation_delay = '0s', animation_duration = '0s', skip_auto_prev_state = section === prev_section && selector === prev_selector, forward_only = false, backward_only = false, ease = false, linear = false, continuous = false } of global_animations.filter(e => e)) {
		if (section !== (prev_section ?? section)) {
			all_styles.set(prev_section, styles.join("\n"));
			styles = new Array();
		}
		i += 1;
		const keyframe_entries = Object.entries(keyframes).map(([a, b]) => [+a, b]).sort((a, b) => a[0] - b[0]);
		if (keyframe_entries[0]?.[0] !== 0) throw "Missing keyframe 0";
		if (keyframe_entries[keyframe_entries.length - 1]?.[0] !== 100) throw "Missing keyframe 100";

		if (selector !== prev_selector || slide_num !== prev_slide_num) {
			animations.length = 0;
		}

		const animation = `animation${i} ${animation_duration} ${linear ? "linear" : ease ? "ease" : "cubic-bezier(0.69, 0.02, 0.53, 1)"} ${animation_delay} 1 forwards normal`;
		animations.push(animation)

		let selectors = selector.split(',');

		if (!skip_auto_prev_state) {
			styles.push(`.slide#${section} ${selector} {
		${Object.entries(keyframe_entries[0][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	}`);
		}

		// if (selector.startsWith('.')) {
		// 	Array.prototype.push.apply(selectors, [...document.querySelectorAll(selector)].filter(x => x.id).map(x => `${selector}#${x.id}`));
		// }

		styles.push(`${selectors.map(selector => `.slide#${section}[${continuous ? 'fragment-' : 'click="'}${slide_num}${continuous ? '' : '"'}]${forward_only ? "[present-went-forward]" : backward_only ? "[present-went-backward]" : ""} ${selector}`).join(',\n')} {
		animation: ${animations.join(",\n\t")};
	}`);

		if (!continuous) styles.push(`${selectors.map(selector => `.slide#${section}[fragment-${slide_num + 1}] ${selector}`).join(',\n')} {
		${Object.entries(keyframe_entries[keyframe_entries.length - 1][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	}`);

	// 	if (forward_only) styles.push(`${`${selectors.map(selector => `.slide#${section}[click="${slide_num}"][present-went-backward] ${selector}`).join(',\n')} {
	// 	${Object.entries(keyframe_entries[keyframe_entries.length - 1][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	// }`}`);

		styles.push(`@keyframes animation${i} {
		${keyframe_entries.map(([a, b]) => `${a}% { ${Object.entries(b).map(([a, b]) => `${a}: ${b};`).join(" ")} }`).join("\n\t")}
	}`);

		if (forward_only) {
			// console.log(styles[styles.length - 1]);
		}

		prev_selector = selector;
		prev_slide_num = slide_num;
		prev_section = section;
	}

	all_styles.set(prev_section, styles.join("\n"));

	var styleSheet = document.createElement("style");
	styleSheet.id = "slide-animations";
	styleSheet.innerHTML = [...all_styles.values()].join('\n');
	document.head.appendChild(styleSheet);
}

	const getStateFromURL = () => {
		const slide_arg = window.location.href.split("#").pop();
		const [slide_title, clicks_amt] = slide_arg.split("?");
		let cur_slide = slide_title || slide_elements[0].id;
		if (!clicks.has(cur_slide)) [[cur_slide]] = clicks;

		return [
			cur_slide,
			(clicks_amt || "").startsWith("click=")
			? Math.min(clicks.get(cur_slide) - 1, parseInt(clicks_amt.slice("click=".length)) || 0)
			: 0
		];
	}

	let [cur_slide, cur_click] = getStateFromURL();

	const updateURL = () => window.location.href = "#" + cur_slide + (cur_click === 0 ? '' : `?click=${cur_click}`);

	const updateContainerSlideAttribute = () => {
		container.setAttribute("slide", cur_slide);
		overlay.setAttribute("slide", cur_slide + "-overlay");
	}


	// window.onhashchange = function() {
	// 	const targetState = getSlideFromURL();
	// 	setState(targetState)
	// };

	function applyTransitions() {
		for (const cur_slide_element of slidesById.get(cur_slide)) {
			cur_slide_element.setAttribute("click", "" + cur_click);
			for (let i = 0; i <= cur_click; i++) cur_slide_element.setAttribute(`fragment-${i}`, "");
			const max_clicks = clicks.get(cur_slide);
			for (let i = cur_click; ++i < max_clicks; ) cur_slide_element.removeAttribute(`fragment-${i}`);
		}

		for (const state_transition of state_transitions.get(cur_slide)[cur_click]) {
			state_transition();
		}
	}

	function applyStateTransitionsUpToCurrentClickInSlide() {
		for (let i = 0; i <= cur_click; i++) {
			for (const state_transition of state_transitions.get(cur_slide)[i]) {
				state_transition();
			}
		}
	}

	function nextSlide() {
		let next_slide;
		let wasPreviousCurrentSlide = false;
		for (const [slide] of clicks) {
			if (wasPreviousCurrentSlide) {
				next_slide = slide;
				break;
			}
			wasPreviousCurrentSlide = cur_slide === slide;
		}
		if (!next_slide) return false;
		for (const cur_slide_element of slidesById.get(cur_slide)) {
			for (let i = 0; i < cur_click; i++) {
				cur_slide_element.removeAttribute(`fragment-${i}`);
			}
			cur_slide_element.removeAttribute("click");
			cur_click = 0;
		}

		cur_slide = next_slide;
		updateContainerSlideAttribute();
		return true;
	}

	function goForward() {
		const old_slide = cur_slide;
		const max_click = clicks.get(cur_slide) - 1;
		cur_click++;
		let is_new_slide = true;
		if (cur_click > max_click) {
			is_new_slide = nextSlide();
			if (!is_new_slide)
				cur_click--;
		}
		for (const old_slide_element of slidesById.get(old_slide)) {
			old_slide_element.removeAttribute("present-went-backward");
			if (old_slide !== cur_slide) old_slide_element.removeAttribute("present-went-forward");
		}
		for (const cur_slide_element of slidesById.get(cur_slide)) cur_slide_element.setAttribute("present-went-forward", "");
		if (is_new_slide) {
			applyTransitions();
			updateURL();
		}
	}

	function prevSlide() {
		for (const slide of slidesById.get(cur_slide)) {
			slide.removeAttribute("click");
			slide.removeAttribute("fragment-0");
		}
		let [[previous_slide]] = clicks
		for (const [slide] of clicks) {
			if (cur_slide === slide) break;
			previous_slide = slide;
		}
		cur_slide = previous_slide;
		cur_click = clicks.get(cur_slide) - 1;
		applyStateTransitionsUpToCurrentClickInSlide();
		updateContainerSlideAttribute();
	}

	function goBackward() {
		const old_slide = cur_slide;

		if (cur_click === 0) {
			prevSlide();
		} else {
			cur_click--;
		}

		for (const old_slide_element of slidesById.get(old_slide)) {
			old_slide_element.removeAttribute("present-went-forward");
			if (old_slide !== cur_slide) old_slide_element.removeAttribute("present-went-backward");
		}
		for (const slide of slidesById.get(cur_slide)) slide.setAttribute("present-went-backward", "");

		applyTransitions();
		updateURL();
	}

	let is_control_depressed = false;

	window.addEventListener("touchstart", () => document.querySelector("body").requestFullscreen({ navigationUI: "hide" }));
	window.addEventListener("keyup", function (event) {
		// Do nothing if the event was already processed
		if (event.defaultPrevented) return;
		switch (event.key) {
		case "Control":
			is_control_depressed = false;
			break;
		default:
			return; // Quit when this doesn't handle the key event.
		}
	});

	window.addEventListener("keydown", function (event) {
		// Do nothing if the event was already processed
		if (event.defaultPrevented) return;

		switch (event.key) {
		case "ArrowLeft":
			goBackward();
			break;
		case "ArrowRight":
			goForward();
			break;
		case "Control":
			is_control_depressed = true;
			break;
		case 'c':
			if (is_control_depressed) {
				navigator.clipboard.writeText(code_snippets.get(cur_slide));
			}
		default:
			return; // Quit when this doesn't handle the key event.
		}

		// Cancel the default action to avoid it being handled twice
		event.preventDefault();
	}, true);

	applyTransitions();
	updateURL();
	applyStateTransitionsUpToCurrentClickInSlide();
	updateContainerSlideAttribute();
	for (const slide of slidesById.get(cur_slide)) slide.setAttribute("present-went-forward", "");
</script>


<script>
function subtractBinary(a, b) {
    // Convert binary strings to integers
    const intA = BigInt(`0b${[...a.replaceAll('.', '0')].reverse().join('')}`);
    const intB = BigInt(`0b${[...b.replaceAll('.', '0')].reverse().join('')}`);

    // Subtract
    let result = intA - intB;
	const flip_around = result < 0n;

    // If negative, handle appropriately
    if (flip_around) {
        result = ~result;
    }

	let str = result.toString(2).padStart(64, '0');

	if (flip_around) {
        str = str.replaceAll(/[01]/g, e => ['1', '0'][+e]);
    }

    // Convert back to binary string
    return [...str.replaceAll('0', '.')].reverse().join('');
}

function opBinary(a, b, op) {
    // Convert binary strings to integers
    const intA = BigInt(`0b${[...a.replaceAll('.', '0')].reverse().join('')}`);
    const intB = BigInt(`0b${[...b.replaceAll('.', '0')].reverse().join('')}`);

    // Subtract

    let result = undefined;

	switch (op) {
		case '-': result = intA - intB; break;
		case '^': result = intA ^ intB; break;
		case '&': result = intA & intB; break;
		case '&~': result = intA & ~intB; break;
		case '|': result = intA | intB; break;
	}

	const flip_around = result < 0n;

    // If negative, handle appropriately
    if (flip_around) {
        result = ~result;
    }

	let str = result.toString(2).padStart(64, '0');

	if (flip_around) {
        str = str.replaceAll(/[01]/g, e => ['1', '0'][+e]);
    }

    // Convert back to binary string
    return [...str.replaceAll('0', '.')].reverse().join('');
}

// Example:
const even_series = opBinary(
	"0111.111.1..1111.1.11111.11111.111111111.11111.1111.1111111111.1",
	"11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11", '-');

const esc_and_term = opBinary(even_series, '.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1', '^');
const escaped = opBinary(esc_and_term, "11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11", "^");
// console.log(even_series);
// console.log(esc_and_term);
// console.log(escaped);

// console.log(opBinary(
// 	"1....1.....1...11...1.1..1.......11............11............1..",
// 	"1...............1.................1..............1..............", "-"));

// const starts_and_quote_bounds = opBinary("...............1.................1..............1...............", opBinary("1..........1....1.....1........................1................", opBinary("...............1.................1..............1...............",
// opBinary("1...............1.................1..........................1.." & "1..........1....1.....1........................1................", "&"), '-'), '&'), '|');

const starts = "1...............1.................1..........................1..";
const quote_bounds_incl_carry = "1..........1....1.....1........................1................";
const starts_and_quote_bounds = opBinary(starts, quote_bounds_incl_carry, '&');
const carriages_or_newlines_or_eof = "...............1.................1..............1...............";
const subbed = opBinary(carriages_or_newlines_or_eof, starts_and_quote_bounds, '-');
const imm = opBinary(quote_bounds_incl_carry, subbed, '&');
let imm2 = opBinary(carriages_or_newlines_or_eof, imm, '|');
imm2 = opBinary(imm2, starts, '&~');

const cur_ends = opBinary(imm2, opBinary(imm2, starts, '-'), '&~');


console.log({cur_ends});

</script>

<style>
	.bits-small {
		font-size: 25px;
		letter-spacing: -2px;
		text-align: center;
	}
</style>

</body>
</html>
