<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="utf-8">
	<title>fill vs init</title>
	<link rel="stylesheet" type="text/css" href="./fonts/Iosevka/Iosevka.css">
	<style>
		[hidden] {
		  display: none;
		}

		g.slide:not([hidden]) > .h2:first-child:not(.code),
		g.slide:not([hidden]) > [click]:not([hidden]):not(.no-slide-in):not(.no-slide-in2):not(.code),
		g.slide:not([hidden]) > [click]:not([hidden]):not(.code) text:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > [click]:not([hidden]):not(.code) tspan:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg):not(.code) text:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg):not(.code) tspan:not(.highlighted):not(.highlighted-blue),

		g.slide:not([hidden]) > g:not(.no-slide-in) > .h2:first-child:not(.code),
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]):not(.no-slide-in):not(.no-slide-in2):not(.code),
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]):not(.code) text:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]):not(.code) tspan:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg):not(.code) text:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg):not(.code) tspan:not(.highlighted):not(.highlighted-blue)
		{
			animation: unhide 0.5s cubic-bezier(0, 0, 0.53, 1) 0s 1 forwards;
		}


		g.slide:not([hidden]) > [click]:not([hidden]) text.highlighted,
		g.slide:not([hidden]) > [click]:not([hidden]) tspan.highlighted,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) text.highlighted,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) tspan.highlighted,
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]) text.highlighted,
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]) tspan.highlighted,
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg) text.highlighted,
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg) tspan.highlighted
		{
			animation: unhide-highlighted 0.5s cubic-bezier(0, 0, 0.53, 1) 0s 1 forwards;
		}

		g.slide:not([hidden]) > [click]:not([hidden]) text.highlighted-blue,
		g.slide:not([hidden]) > [click]:not([hidden]) tspan.highlighted-blue,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) text.highlighted-blue,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) tspan.highlighted-blue,
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]) text.highlighted-blue,
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]) tspan.highlighted-blue,
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg) text.highlighted-blue,
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg) tspan.highlighted-blue,
		g.slide > g > text > tspan > tspan.highlighted-blue
		{
			animation: unhide-highlighted-blue 0.5s cubic-bezier(0, 0, 0.53, 1) 0s 1 forwards;
		}

		g.slide:not([hidden]) {
			animation: unhide-slide 0.5s ease 0s 1 forwards;
		}

		.unhide-slide:not(.no-slide-in):not(.no-slide-in2) {
			animation: unhide-slide 0.5s ease 0s 1 forwards;
		}

		.unhide-slide.no-slide-in {
			animation: no-unhide-slide 0.5s ease 0s 1 forwards;
		}

		.unhide-slide.no-slide-in2 {
			animation: no-unhide-slide2 0.5s ease 0s 1 forwards;
		}

		.hide-slide {
			animation: hide-slide 0.5s ease 0s 1 forwards;
		}


		@keyframes unhide {
			0%   { transform: translateY(-60px); stroke: rgba(255, 255, 255, 1); stroke-width: 5px; }
			100% { transform: translateY(0); stroke: rgba(255, 255, 255, 0) }
		}

		@keyframes unhide-highlighted {
			0%   { transform: translateY(-60px); stroke: rgba(255, 255, 255, 1); stroke-width: 5px; }
			100% { transform: translateY(0); stroke: rgba(0, 255, 255, 1); stroke-width: 2px; }
		}

		@keyframes unhide-highlighted-blue {
			0%   { transform: translateY(-60px); stroke: rgba(255, 255, 255, 1); stroke-width: 5px; }
			100% { transform: translateY(0); stroke: rgb(255, 177, 100); stroke-width: 2px; }
		}

		@keyframes unhide-slide {
			from   { transform: translateY(-60px); }
		}

		@keyframes no-unhide-slide {
			from   { transform: translateY(60px); }
		}

		@keyframes no-unhide-slide2 {
			/* from   { transform: translate(150px, -550px) rotate(45deg); } */
		}

		@keyframes hide-slide {
			to   { transform: translateY(-60px); opacity: 0; }
		}

		g.slide#title {
			animation: unhide-svg 10s cubic-bezier(0, 1, 0, 1) 0s 1 forwards !important;
		}

		@keyframes unhide-svg {
			0%   { transform: scale(0) translate(1100px, 1600px); }
			100% { transform: scale(1) translate(0, 0); }
		}

		@font-face {
			font-family: 'Press Start 2P';
			src: url('./fonts/Press_Start_2P/PressStart2P-Regular.ttf') format('truetype');
			font-weight: 400;
			font-style: normal;
			font-display: block;
		}

		@font-face {
			font-family: 'Ysabeau Office';
			src: url('./fonts/Ysabeau_Office/static/YsabeauOffice-Regular.ttf') format('truetype');
			font-weight: 400;
			font-style: normal;
			font-display: block;
		}

		@font-face {
			font-family: 'Ysabeau Office';
			src: url('./fonts/Ysabeau_Office/static/YsabeauOffice-Medium.ttf') format('truetype');
			font-weight: 500;
			font-style: normal;
			font-display: block;
		}

		* {
			padding: 0;
			margin: 0;
			box-sizing: border-box;
		}

		html, body, #container, #overlay {
			height: 100%;
			width: 100%;
			font-size: 12pt
		}

		.h1, .h2, .h3, .h4 {
			font-family: "Press Start 2P";
			color: hsl(265, 89%, 78%);
			text-align: center;
			line-height: 1.25;
			letter-spacing: -1px;
		}

		.h2, .h3, .h4 {
			fill: hsl(265, 89%, 78%);
		}

		h1, .h1 {
			font-size: 8rem;
		}

		h2, .h2 {
			font-size: 4.25rem;
		}

		.h3 {
			font-size: 2.75rem;
		}

		.h4 {
			font-size: 2rem;
		}

		#container, #overlay {
			height: 100%;
			width: 100%;
			position: absolute;
			background-color: #000
			/* animation: container-background 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0s 1 forwards; */
		}

		#overlay {
			position: fixed;
			background: none;
		}

		@keyframes container-background {
			0% { background-color: hsl(231, 15%, 18%) }
			100%   { background-color: #000 }
		}

		/* .slide {
			padding-top: 1in;
			padding-bottom: 1in;
			padding-left: 1in;
			padding-right: 1in;
		} */

		ol, ul, p, pre {
			font-size: 2.5rem;
			color: #F8F8F2;
			font-family: "Press Start 2P";
			line-height: 1.25;
			letter-spacing: -2px;
		}

		ol, ul, p {
			margin-left: 4rem;
		}

		.slide > p,
		.slide > ul,
		.slide > ol {
			margin-top: 1rem;
		}

		ol ol {
			list-style-type: lower-alpha;
		}

		a {
			color:aqua
		}
	</style>


<style>

.stroke-rain {
	stroke: hsl(0, 100%, 50%);
	animation: strokeHue 2s linear infinite !important;
}

@keyframes strokeHue {
	0%   { stroke: hsl(0,   100%, 50%); }   /* red */
	25%  { stroke: hsl(90,  100%, 50%); }   /* green */
	50%  { stroke: hsl(180, 100%, 50%); }   /* cyan */
	75%  { stroke: hsl(270, 100%, 50%); }   /* purple */
	100% { stroke: hsl(360, 100%, 50%); }   /* back to red */
}

.sub {
	font-size: 60%;
	baseline-shift: -10px;
	letter-spacing: -8px;
}

.super {
	font-size: 60%;
	baseline-shift: 20px;
	letter-spacing: -8px;
}

.sub-space {
	letter-spacing: -11px;
}

.undies {
	font-size: 80%;
}

.ceil {
	baseline-shift: 13px;
}

.hidey-ones {
	opacity: 0;
}

.bullet {
	font-size: 112.5%;
	baseline-shift: 0px;
	letter-spacing: -8px;
}

.bullet-dot {
	font-size: 150%;
	baseline-shift: 6px;
	letter-spacing: -8px;
}

.bullet-dot-rot {
	font-size: 150%;
	baseline-shift: -4px;
    letter-spacing: -21px;
	transform: rotate(45deg)
}

.invis {
	opacity: 0;
}
</style>


	<script>
	    const global_animations = [];
		const global_scrolls = [];
		const state_transitions = new Map();
		const post_processes = [];
	</script>
</head>

<body style="padding-bottom: 0px; padding-right: 0px">

<svg id="container" viewBox="0 0 1920 1080" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMin meet">
	<g class="slide" id="pre-title"></g>
	<g class="slide" id="title">
		  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7"
            refX="8" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" stroke="rgb(0, 255, 255)"/>
    </marker>

	<marker id="arrowhead-orange" markerWidth="10" markerHeight="7"
            refX="8" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" stroke="rgb(255, 177, 100)"/>
    </marker>
  </defs>
		<text class="h1 title-line" x="965" y="500" fill="#F7A41D" text-anchor="middle">fill vs init</text>
		<!-- <text class="h1 title-line" x="965" y="575" fill="#F7A41D" text-anchor="middle">HHID Cache</text> -->

		<g class="title-line">
			<text class="h1" x="965" y="700" fill="#F7A41D" text-anchor="middle">in &nbsp;&nbsp;&nbsp;</text>

			<svg id="zig-logo" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="-1 0 154 140" height="280" width="280" x="965" y="500">
				<g fill="#F7A41D">
					<g id="logo-left-side">
						<polygon points="46,22 28,44 19,30"></polygon>
						<polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"></polygon>
						<polygon points="31,95 12,117 4,106"></polygon>
					</g>
					<g id="logo-middle">
						<polygon points="56,22 62,36 37,44"></polygon>
						<polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"></polygon>
						<polygon points="116,95 97,117 90,104"></polygon>
						<polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"></polygon>
						<polygon points="150,0 52,117 3,140 101,22"></polygon>
					</g>
					<g id="logo-right-side">
						<polygon points="141,22 140,40 122,45"></polygon>
						<polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"></polygon>
						<polygon points="125,95 130,110 106,117"></polygon>
					</g>
				</g>
			</svg>
		</g>

		<text class="h2" id="by-line-1" x="960" y="875" text-anchor="middle">by Niles Salter</text>
		<text class="h3" id="by-line-2" x="960" y="975" text-anchor="middle"><tspan style="stroke: rgb(0, 255, 255);
		stroke-width: 2px">https://validark.dev</tspan></text>

		<script>
			const EXTRA_DELAY = 0.25;

			global_animations.push({
				section: "title",
				selector: ".title-line, #zig-logo",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { "letter-spacing": "-1em", opacity: 0, transform: "scale(0.25) translate(140rem, 50rem)", "font-size": "1rem" },
					30:  { opacity: 1, "font-size": "8rem" },
					100: { "letter-spacing": "-1px", opacity: 1, transform: "scale(1) translate(0, 0)", "font-size": "8rem" },
				}
			}, {
				section: "title",
				selector: ".title-line > text",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "3s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { "letter-spacing": "-1em" },
					100: { "letter-spacing": "-1px" },
				}
			}, {
				section: "title",
				selector: "#by-line-1, #by-line-2",
				slide_num: 0,
				animation_delay: `${2 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { "letter-spacing": "-1em", opacity: 0 },
					25:  { opacity: 1 },
					100: { "letter-spacing": "-7px", opacity: 1 },
				}
			}, {
				section: "title",
				selector: "#logo-left-side",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(75px)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			}, {
				section: "title",
				selector: "#logo-right-side",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(-75px)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			}, {
				section: "title",
				selector: "#logo-middle",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(0)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			});
		</script>
	</g>

	<g class="slide" id="prelim">
		<text class="h2" x="980" y="100" text-anchor="middle">init and deinit</text>

		<g class="code" x="100" y="200" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig" hide-line-numbers lang="zig" steps="1,2,4,5,6,7,8,9,12,13,14,15,16,20,22,24,26">
const Foo = struct {
	memory: []const u8,

	pub fn init(
		allocator: std.mem.Allocator,
		payload: []const u8,
	) !@This() {
		const memory = try allocator.dupe(u8, payload);
		return .{ .memory = memory };
	}

	pub fn deinit(
		self: @This(),
		allocator: std.mem.Allocator,
	) void {
		allocator.free(self.memory);
	}
};

const foo: Foo = try .init(gpa, payload);
// or
const foo = try Foo.init(gpa, payload);

defer foo.deinit();
// or
errdefer foo.deinit();



		</g>
	</g>

		<g class="slide" id="more-complicated">
		<g class="code" x="0" y="0" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig" hide-line-numbers lang="zig" steps="2:2,7:2,10:6">
const Foo = struct {
	mem1: []const u8,
	mem2: []const u8,

	pub fn init(
		allocator: std.mem.Allocator,
		payload1: []const u8,
		payload2: []const u8,
	) !@This() {
		const mem1 = try allocator.dupe(u8, payload1);
		const mem2 = try allocator.dupe(u8, payload2);
		return .{
			.mem1 = mem1,
			.mem2 = mem2,
		};
	}

	pub fn deinit(
		self: @This(),
		allocator: std.mem.Allocator,
	) void {
		allocator.free(self.mem1);
		allocator.free(self.mem2);
	}
};
</g>
	</g>

	<g class="slide" id="more-complicated-fixed">
		<g class="code" x="0" y="0" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig" hide-line-numbers lang="zig" steps="10:8">
const Foo = struct {
	mem1: []const u8,
	mem2: []const u8,

	pub fn init(
		allocator: std.mem.Allocator,
		payload1: []const u8,
		payload2: []const u8,
	) !@This() {
		const mem1 = try allocator.dupe(u8, payload1);
		errdefer allocator.free(mem1);
		const mem2 = try allocator.dupe(u8, payload2);
		errdefer allocator.free(mem2);
		return .{
			.mem1 = mem1,
			.mem2 = mem2,
		};
	}

	pub fn deinit(
		self: @This(),
		allocator: std.mem.Allocator,
	) void {
		allocator.free(self.mem1);
		allocator.free(self.mem2);
	}
};
</g>
	</g>


	<g class="slide" id="fill-1">
		<text class="h2" x="980" y="100" text-anchor="middle">The fill pattern</text>
		<g class="code" click="1" x="0" y="200" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background
		lang="zig" hide-line-numbers lang="zig" steps="2:2,25,26,15:4,19:2,46,47,48,49:2,51,26,28,5:9,11:2,25:4">
const Foo = struct {
	mem1: []const u8 = &.{},
	mem2: []const u8 = &.{},

	pub fn fill(
		self: *@This(),
		allocator: std.mem.Allocator,
		payload1: []const u8,
		payload2: []const u8,
	) !void {
		self.mem1 = try allocator.dupe(u8, payload1);
		self.mem2 = try allocator.dupe(u8, payload2);
	}

	pub fn deinit(
		self: @This(),
		allocator: std.mem.Allocator,
	) void {
		allocator.free(self.mem1);
		allocator.free(self.mem2);
	}
};

{
	const foo: Foo = .{};
	defer foo.deinit();

	try foo.fill();
}













/// Free an array allocated with `alloc`.
/// If memory has length 0, free is a no-op.
/// To free a single item, see `destroy`.
pub fn free(self: Allocator, memory: anytype) void {
    const Slice = @typeInfo(@TypeOf(memory)).pointer;
    const bytes = mem.sliceAsBytes(memory);
    const bytes_len = bytes.len + if (Slice.sentinel() != null)
		@sizeOf(Slice.child) else 0;
    if (bytes_len == 0) return;
    const non_const_ptr = @constCast(bytes.ptr);
    @memset(non_const_ptr[0..bytes_len], undefined);
    self.rawFree(
		non_const_ptr[0..bytes_len],
		.fromByteUnits(Slice.alignment),
		@returnAddress(),
	);
}
</g>
	</g>
	<g class="slide" id="end">
		<text class="h2" x="960" y="525" text-anchor="middle" style="font-size: 100px; letter-spacing:kz
		0.1px;">fin</text>


<script>
{
	const bullets = {
		0: "&lt;tspan class=\"bullet\"&gt;&bullet;&lt;/tspan&gt;&ThinSpace;&ThinSpace;&ThinSpace;&ThinSpace;",
		2: "&lt;tspan class=\"bullet-dot\"&gt;.&lt;/tspan&gt;&ThinSpace;",
		4: "&ThinSpace;&ThinSpace;&lt;tspan rotate=\"-45\" class=\"bullet-dot-rot\"&gt;.&lt;/tspan&gt;&ThinSpace;",
	};

	const semicolons = {
		0: "&lt;tspan class=\"invis bullet\"&gt;&bullet;&lt;/tspan&gt;&ThinSpace;&ThinSpace;&ThinSpace;&ThinSpace;",
		2: "&lt;tspan class=\"invis bullet-dot\"&gt;.&lt;/tspan&gt;&ThinSpace;",
		4: "&ThinSpace;&ThinSpace;&lt;tspan rotate=\"-45\" class=\"invis bullet-dot-rot\"&gt;.&lt;/tspan&gt;&ThinSpace;",
	};

	const colors2 = new Map([
		["cyan", "rgb(0, 255, 255)"],
		["orange", "rgb(255, 177, 100)"],
		["red-orange", "rgb(240, 86, 39)"],
		["red", "rgb(255, 99, 132)"],
		["green", "rgb(50, 255, 50)"],
		["yellow", "rgb(255, 255, 102)"],
		["pink", "rgb(255, 112, 255)"],
		["blue", "rgb(70, 255, 180)"],
		["pink", "rgb(255, 15, 180)"],
		["gold", "rgb(255, 215, 20)"],
		["white", "rgb(255, 255, 255)"],

		<!-- lime green: rgb(70, 255, 180) -->
	]);


	for (const bulleted of document.getElementsByClassName("bullets")) {
		let click_offset = 1;
		let iter = 0;
		let iter2 = 0;
		let y = +bulleted.getAttribute('y') - 70;
		let tmp = 0;


		let lines = bulleted.innerHTML
			.split('\n')
			.filter(e => e.trim())
			.flatMap(e => {
				const sub_lines = e.split(';');
				const first_line_prefix = sub_lines[0].match(/^ */)[0];
				for (let i = 0; ++i < sub_lines.length;)
					sub_lines[i] = first_line_prefix + ';' + sub_lines[i];
				return sub_lines;
			});

		console.log(lines);

		const unnecessary_whitespace = lines
			.reduce((a, c) => Math.min(a, c.length - c.trimLeft().length), Number.POSITIVE_INFINITY);

		function boop(x,y) {
			console.log({x,y})
			return colors2.get(x);
		}

		const my_lines = lines.map((x, i) => {
			x = x.slice(unnecessary_whitespace);
			const is_cont = x.match(/^ *;/);
			console.log(is_cont ? 1 : 0, x);
			x = x.replaceAll(/^~/g, (_, spaces) => (click_offset++, ""));
			x = x.replace(/^( *):/, (_, spaces) => "&nbsp;".repeat(spaces.length) + bullets[spaces.length]);
			x = x.replace(/^( *);/, (_, spaces) => "&nbsp;".repeat(spaces.length) + semicolons[spaces.length]);
			x = x.replace(/^( *)/, (_, spaces) => "&nbsp;".repeat(spaces.length));
			console.log('a', x);
			x = x.replaceAll(/([^\\]):([)OopPD(])(?!\w)/g, (_, char, content) => char + `&lt;tspan style="letter-spacing: -32px" rotate="90" fill=\"${'cyan'}\"&gt;&lt;tspan style="baseline-shift: 42px;"&gt;:&lt;/tspan&gt;&lt;tspan style="baseline-shift: 22px;"&gt;${content}&lt;/tspan&gt;&lt;/tspan&gt;`);
			console.log('b', x);
			x = x.replaceAll(/([^\\]):(.+?):{(.+?)\}/g, (_, char, color, content) => char + `&lt;tspan fill=\"${boop(color, content)}\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/\_\{(.+?)\}/g, (_, content) => `&lt;tspan class=\"sub\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/\^\{(.+?)\}/g, (_, content) => `&lt;tspan class=\"super\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/```(.+?)```/g, (_, content) => `&lt;tspan class=\"stroke-rain\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/``(.+?)``/g, (_, content) => `&lt;tspan class=\"highlighted\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/`(.+?)`/g, (_, content) => `&lt;tspan class=\"highlighted-blue\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll("naive", "naïve");
			x = x.replaceAll("\\:", ":");

			return `&lt;text click="${i + click_offset}" class="h4" x="30" y="${y += 45 + (is_cont ? 0 : 35) }" text-anchor="start"&gt;${x}&lt;/text&gt;`
		}).join("");
		console.log(my_lines);
		bulleted.innerHTML = my_lines;
	}

	for (const codeblock of document.getElementsByClassName("code")) {
		const steps = codeblock.getAttribute("steps") || codeblock.getAttribute("mini-steps");
		if (steps) {
			let slide = codeblock;
			do slide = slide.parentNode; while (!slide.classList.contains("slide"));
			slide.setAttribute('clicks', steps.split(',').length + 1);
		}
	}

	for (const slide of document.getElementsByClassName("slide")) {
		const title = slide.getAttribute('title')
		if (title) {
			slide.insertAdjacentHTML("afterbegin", `&lt;text class="h2" x="980" y="100" text-anchor="middle"&gt;${title}&lt;/text&gt;`);
		}
	}



}
</script>
	</g>
</svg>

<svg id="overlay" style="overflow: hidden; width: 100%;" y="5000" viewBox="0 0 1920 1080" version="1.1" xmlns="http://www.w3.org/2000/svg">
</svg>

<style>
	#button-left, #button-right {
		position: fixed;
		font-size: 2rem;
		font-family: 'Press Start 2P';
		bottom: 1rem;
		color: white;
		text-align: center;
		align-content: center;
		height: 1.5rem;
		width: 4rem;
		padding: 0.5rem 0.85rem;
		background: none;
		border: none;
	}

	#button-left {
		left: 0rem;
	}

	#button-right {
		right: 0rem;
	}

	.code-star {
		alignment-baseline: middle;
	}

	.code-color-white { fill: #fff; }
	.code-color-0 { fill: rgb(80, 250, 123); }
	.code-color-1 { fill: #60f4d4; }
	.code-color-2 { fill: rgb(189, 147, 249); }
	.code-color-3 { fill: rgb(255, 121, 198); }
	.code-color-4 { fill: rgb(255, 184, 104); }
	.code-color-5 { fill: #F1FA8C; }
	.code-color-6 { fill: #7960f4; }
	.code-color-7 { fill: #f46060; }
	/* .code-color-8 { fill: #60f4d4; } */

	.code-block-label {
		text-decoration: underline;
		fill: rgb(80, 250, 123);
	}

	.code-builtin {
		fill: rgb(139, 233, 253);
	}

	.code-num {
		fill: rgb(189, 147, 249);
	}

	.code-type, .code-keyword, .code-symbol-1, .code-symbol-2 {
		fill: rgb(255, 121, 198);
	}

	.code-symbol-2 {
		baseline-shift: -14px;
	}

	.code-struct-type {
		fill: rgb(255, 184, 104);
		font-style: italic;
	}

	.code-register {
		fill: #b6c8ff;
	}

	.code-register-2, .code-register-3 {
		fill: rgb(255, 184, 104);
		font-style: italic;
	}

	.code-comment {
		font-style: normal;
		fill: #6272a4;
	}

	.code-type {
		font-style: italic;
	}

	.code-string {
		fill: #F1FA8C;
	}

	.code-space {
		fill: rgb(98, 114, 164);
	}

	.bit-1 {
		fill: #F1FA8C;
	}

	.line-of-code, .line-number, .bits, .label, .small-label, .xsmall-label, .ysmall-label, .big-label {
		font-family: 'Iosevka', 'Press Start 2P', 'Courier New', Courier, monospace;
		font-size: 64px;
		letter-spacing: -6px;
		fill: rgb(248, 248, 242)
	}

	.bits, .bits .code-type {
		font-style: normal;
	}

	.line-number {
		font-size: 45px;
	}

	.label {
		font-size: 40px;
		baseline-shift: 10px;
		letter-spacing: -4px;
	}

	.small-label {
		font-size: 28px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.xsmall-label {
		font-size: 20px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.ysmall-label {
		font-size: 25px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.big-label {
		font-size: 70px;
	}

	.code-func-name {
		fill: rgb(80, 250, 123);
	}

	.code-instruction {
		fill: rgb(255, 121, 198);
	}

	.code-keyword-asm {
		fill: rgb(255, 184, 104);
	}

	.code-curly-0 { fill: rgb(248, 248, 242); }
	.code-curly-1 { fill: rgb(255, 121, 198); }
	.code-curly-2 { fill: rgb(139, 233, 253); }
	.code-curly-3 { fill: rgb(80, 250, 123); }
	.code-curly-4 { fill: rgb(189, 147, 249); }
	.code-curly-5 { fill: rgb(255, 184, 104); }

	.code-paren-0 { fill: rgb(248, 248, 242); }
	.code-paren-1 { fill: #F1FA8C; }
	.code-paren-2 { fill: rgb(255, 184, 104); }
	.code-paren-3 { fill: rgb(255, 121, 198); }
 	.code-paren-4 { fill: rgb(189, 147, 249); }
 	.code-paren-5 { fill: rgb(139, 233, 253); }

	.code-brack-0 { fill: #F1FA8C; }
	.code-brack-1 { fill: rgb(255, 184, 104); }
	.code-brack-2 { fill: rgb(255, 121, 198); }
	.code-brack-3 { fill: rgb(189, 147, 249); }
	.code-brack-4 { fill: rgb(139, 233, 253); }
	.code-brack-5 { fill: rgb(248, 248, 242); }

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Bold-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Bold-Italic.woff') format('woff');
		font-weight: 700;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Bold.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Bold.woff') format('woff');
		font-weight: 700;
		font-style: normal;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold-Italic.woff') format('woff');
		font-weight: 800;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold.woff') format('woff');
		font-weight: 800;
		font-style: normal;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Italic.woff') format('woff');
		font-weight: 400;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Medium-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Medium-Italic.woff') format('woff');
		font-weight: 500;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Medium.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Medium.woff') format('woff');
		font-weight: 500;
		font-style: normal;
		font-display: swap;
	}
	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Regular.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Regular.woff') format('woff');
		font-weight: 400;
		font-style: normal;
		font-display: swap;
	}
</style>

<button id="button-left" onclick="goBackward()">&lt;</button>
<button id="button-right" onclick="goForward()">&gt;</button>

<style>
	.thin-space {
		letter-spacing: -0.3em;
	}
</style>


<script>
	const code_snippets = new Map();
	code_snippets.set("title", "init vs fill\nby Niles Salter (validark.dev)");

	function processRanges(ranges, joined_lines) {
		return ranges
			.reduce((a, [n, start, end]) =>
				`${a.slice(0, start)}<tspan class="code-${n}">${n === "register-2" ? "<tspan class=\"thin-space\">&nbsp;</tspan>" : ""}${
					a.slice(start, end)
					.replaceAll(/ +/g, e => "&nbsp;".repeat(e.length))
				}${n === "register-2" ? "<tspan class=\"thin-space\">&nbsp;</tspan>" : ""}</tspan>${a.slice(end)}`,
				joined_lines.replaceAll("&gt;", ">").replaceAll("&lt;", "<")
			)
			.split('\n');
	}

	function preprocess(slide_id, text, lang) {
		let start_pos = text.indexOf("\n");
		let end_pos = text.lastIndexOf("\n");

		if (text.slice(0, start_pos + 1).trim() !== "")
			start_pos = -1;

		if (text.slice(end_pos, -1).trim() !== "")
			end_pos = -1

		let lines = text
			.slice(start_pos + 1, end_pos)
			.split('\n')
			.map(e => e.trimRight().replaceAll('\t', '    '));

		const unnecessary_whitespace = lines
			.filter(e => e)
			.reduce((a, c) => Math.min(a, c.length - c.trimLeft().length), Number.POSITIVE_INFINITY);

		lines = lines.map(e => e.slice(unnecessary_whitespace));
		code_snippets.set(slide_id, (code_snippets.get(slide_id) || "") +
			lines
				.join("\n")
				.replaceAll("&gt;", ">")
				.replaceAll("&lt;", "<")
				.replaceAll("&amp;", "&")
		);
		let curly_depth = 0;
		let paren_depth = 0;

		const joined_lines = lines.join('\n')
			.replaceAll("&gt;&gt;", "&raquo;")
			.replaceAll("&lt;&lt;", "&laquo;")
			.replaceAll("-&gt;", "&RightArrow;")
			.replaceAll(" =&gt; ", " &rArr; ")
			.replaceAll(" != ", " &ne; ")
			.replaceAll(" &lt;= ", " &le; ")
			.replaceAll(" &gt;= ", " &ge; ")
			// .replaceAll(" == ", " &Equal; ")
			.replaceAll("&lt;", "<")
			.replaceAll("&gt;", ">");

		const ranges = new Array();

		// for (; )
		// for (let regex = /".+?"/g, cur = regex.exec(joined_lines); cur; cur = regex.exec(joined_lines));

		// const meme = RegExp.prototype.exec.bind(/".+?"/g, joined_lines);
		// joined_lines;

		const in_match = new Array(joined_lines.length).fill(false);

		if (lang === 'zig' || lang === 'ziggy') {
			// console.log(joined_lines);

			// let pos = 0;
			for (const match of joined_lines.matchAll(lang === "ziggy"
			? /\/\/([^_]*|$)|"[^_]*?(?<!\\)"|'[^_]*?'|\\\\([^_]*|$)/g
			: /\/\/([^\n]*|$)|"[^\n]*?(?<!\\)"|'[^\n]*?'|\\\\([^\n]*|$)/g)) {
				const { index, 0: { length } } = match;
				for (let q = 0; q < length; q++) in_match[index + q] = true;
				ranges.push([match[0][0] === '/' ? "comment" : "string", index, index + length]);
			}



			// for (const [regex, name] of [
			// 	[/\/\/([^\n]*|$)/g, "comment"],
			// 	[/"[^\n]*?"|'[^\n]*?'/g, "string"],
			// ]) {
			// 	outer: for (const { index, 0: s } of joined_lines.matchAll(regex)) {
			// 		const { length } = s;
			// 		// console.log({index, length, s})
			// 		for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
			// 		for (let q = 0; q < length; q++) in_match[index + q] = true;
			// 		ranges.push([name, index, index + length]);
			// 	}
			// }

			for (const [regex, name] of [
				[/(?<!\w)(usingnamespace|linksection|threadlocal|unreachable|addrspace|allowzero|nosuspend|anyframe|callconv|comptime|continue|errdefer|noinline|volatile|anytype|noalias|suspend|export|undefined|extern|inline|opaque|orelse|packed|false|true|null|resume|return|struct|switch|align|async|await|break|catch|const|defer|error|union|while|else|enum|test|and|asm|for|pub|try|var|fn|if|or)(?!\w)/g, "keyword"],
				[/(?<!\w)(Carry|HHID|Foo|Bar|Allocator|IndexItem|FastDivider32|IpAddress|T)(?!\w+)/g, "struct-type"],
				[/@\w+/g, "builtin"],
				[/ +/g, "space"],
				[/(?:&rArr;)|(?:&amp;)|(?:&ne;)|(?:&le;)|(?:&ge;)|(?:&Equal;)|(?:&raquo;)|(?:&laquo;)|(?:&RightArrow;)|[+*-]?%|\.\.\.?|[:=><!+~?|^/-]|\.(?=\*)|(?<!\.)\*/ug, "symbol-1"],
				[/(?<=\.)\*/g, "symbol-2"],
				[/\w+(?=\()|(?<=fn )\w+/g, "func-name"],
				[/(?<!\w)(?:[ui]\d+|void|bool|u?int|[ui]size)(?!\w)/g, "type"],
				[/(?<!\w)0x[\dA-Fa-f]+/g, "num"],
				[/(?<!\w)(?:0[b])?\d+/g, "num"],
				[/\*/g, "star"],
			]) {
				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}
		} else if (lang === "asm") {
			for (const [regex, name] of [
				[/"[^\n]+?"|'[^\n]+?'/g, "string"],
				[/;([^\n]+|$)/g, "comment"],
			]) {
				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}

			for (const [regex, name] of [
				[/ +/g, "space"],
				[/\+/g, "symbol-1"],
				[/\*/g, "star"],
				[/(?<!\w)(?:[re]?[abcd]x|[abcd][hl]|[er]?[sb]p|[er]?[ds]i|r[89][bwd]?|r1[0-5][bwd]?|[xyz]mm[0-9]|zmm[12][0-9]|[xy]mm1[0-5]|zmm3[01]|rip)(?!\w)/g, "register"],
				[/(?<=\{)(?:k[0-7])(?=\})/g, "register-2"],
				[/(?<!\w)(?:k[0-7])(?!\w)/g, "register-3"],
				// [/[:=]/g, "symbol-1"],
				[/.LBB\d+_\d+/g, "block-label"],
				[/(?<!\w)0x\d+/g, "num"],
				[/(?<!\w)-?\d+/g, "num"],
				[/(?<=call +)[_.\w]+/g, "func-name"],
				[/(?<=\+ ?)[_.\w]+/g, "func-name"],
				[/(?<=^|\n)[_.\w]+:/g, "func-name"],
				[/(?<!\w)(qword|ptr|dword|byte|word|xmmword|ymmword|zmmword)(?!\w)/g, "keyword-asm"],
				[/(?<=^[ \t]*|\n[ \t]*)\.?\w+/g, "instruction"],
				]) {
					if (name === "instruction") {
						for (const x of joined_lines.matchAll(regex)) {
							const { index, 0: { length } } = x;
							// console.log(index, length, x);
						}
					}

				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					if (length === 0) throw new Error("bad news");
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}
		} if (lang === "rainbow") {
			let cur_color = 0;
			for (let i = 0; i < joined_lines.length; ) {
				for (; i < joined_lines.length && joined_lines[i] !== '1'; i++) {
					ranges.push([`color-white`, i, i + 1]);
				}
				for (; i < joined_lines.length && joined_lines[i] === '1'; i++) {
					ranges.push([`color-${5}`, i, i + 1]);
				}
				cur_color += 1;
			}
		}


		// .replaceAll(//g, (_, pre, e) => `${pre}<tspan class="code-func-name">${e}</tspan>`)

		for (const [regex, name, [opener, closer]] of [
			[/[{}]/g, "curly", "{}"],
			[/[()]/g, "paren", "()"],
			[/[[\]]/g, "brack", "()"],
		]) {
			outer: for (const { index, 0: { 0: e, length } } of joined_lines.matchAll(regex)) {
				for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
				for (let q = 0; q < length; q++) in_match[index + q] = true;
				if (e === closer) {
					curly_depth--;
				}

				ranges.push([`${name}-${curly_depth % 6}`, index, index + length]);

				if (e === opener) {
					curly_depth++;
				}
			}
		}

		return [
			processRanges(ranges.sort(([, a], [, b]) => b - a), joined_lines),
			ranges
		];
	}

	const container = document.getElementById("container");
	const overlay = document.getElementById("overlay");
	const slide_elements = [...container.children];
	const overlay_elements = slide_elements.map(e => document.getElementById(e.id + "-overlay") || (() => {
		// console.log(e);
		overlay.insertAdjacentHTML("beforeend", `<g class="slide" id="${e.id}-overlay"></g>`)
		return document.getElementById(`${e.id}-overlay`);
	})());

	const EmptyFunction = () => {};

	const clicks = new Map();
	const slidesById = new Map();
	const pane_heights = new Map();

function applyState(line, s) {
  line.setAttribute("x1", s.x1);
  line.setAttribute("y1", s.y1);
  line.setAttribute("x2", s.x2);
  line.setAttribute("y2", s.y2);
}

let my_thread = { id: 0 };

// Critically damped (no overshoot, fastest)
const STIFFNESS_DEFAULT = 25;
const zeta = 1; // critical
const DAMPING_DEFAULT = 2 * Math.sqrt(STIFFNESS_DEFAULT) * zeta; // ≈ 10

// Slightly overdamped (no overshoot, a bit “heavier” feel)
// const stiffness = 25;
// const zeta = 1.2;
// const damping = 2 * Math.sqrt(stiffness) * zeta; // ≈ 12


// const STIFFNESS_DEFAULT = 0.6;
// const DAMPING_DEFAULT = 1;



function springTween(line, from, to, opts = {}) {
  let state = { ...from };
  let velocity = { x1: 0, y1: 0, x2: 0, y2: 0 };

  const stiffness = opts.stiffness ?? STIFFNESS_DEFAULT;   // spring strength (per second)
  const damping   = opts.damping   ?? DAMPING_DEFAULT;    // damping (per second)

  const my_thread_id = my_thread.id;
  let lastTime = null;

  function animate(timestamp) {
    if (lastTime === null) lastTime = timestamp;

    const deltaMs = timestamp - lastTime;
    const dt = deltaMs / 500;       // convert to seconds
    lastTime = timestamp;

    let done = true;

    if (my_thread_id === my_thread.id) {
      for (let key in state) {

        // displacement
        const dist = to[key] - state[key];

        // spring force (Hooke's law) scaled by dt
        const springForce = dist * stiffness;

        // damping force scaled by velocity
        const dampingForce = velocity[key] * damping;

        // acceleration
        const accel = springForce - dampingForce;

        // integrate velocity & position
        velocity[key] += accel * dt;
        state[key] += velocity[key] * dt;

        // check if still moving noticeably
        if (Math.abs(dist) > 0.1 || Math.abs(velocity[key]) > 0.01) {
          done = false;
        }
      }
    }

    if (done) {
      applyState(line, to);
    } else {
      applyState(line, state);
      requestAnimationFrame(animate);
    }
  }

  requestAnimationFrame(animate);
}




// <!-- [553, 631], [820, 787], [957, 958], [1157.25, 1129], [1224, 1278] -->
const startState = { x1: 553, y1: 250, x2: 631, y2: 429 };
const endState   = { x1: 820, y1: 250, x2: 787, y2: 429 };

	function recursivelyHandleChildren(child_state_transitions, child, current_click_num) {
		for (const grandchild of child.children) {
			let click_attr = grandchild.getAttribute("click")
			if (click_attr !== null) {
				grandchild.setAttribute("hidden", "");
				const [click, click2] = click_attr.split('-');
				const clicky = (click === "") ? ++current_click_num : parseInt(click) || 1;

				// if (grandchild.id === "change-highlighted-color") {
				// 	console.log({grandchild})
				// }

				if (grandchild.tagName === "line" && clicky && click && click2) {
					//console.log({clicky, click, click2})
					const data1 = [+grandchild.getAttribute("x1"),
										+grandchild.getAttribute("x2"),
										+grandchild.getAttribute("y1"),
										+grandchild.getAttribute("y2"),];

					data1.stiffness = STIFFNESS_DEFAULT;
					data1.damping = DAMPING_DEFAULT;

					const map = new Map([
						[click - 1, data1]
					]);

					for (let i = +click; i <= +click2; i++) {
						const data = grandchild.getAttribute(`click-${i}`)?.split(', ');
						map.set(i, data);
					}

					//console.log({map});
					const thread_incrementers = new Set();

					for (const [i, data] of map.entries()) {
						if (data) {
							const damping = data.damping ?? grandchild.getAttribute("damping") ?? DAMPING_DEFAULT;
							const stiffness = data.stiffness ?? grandchild.getAttribute("stiffness") ?? STIFFNESS_DEFAULT;
							const [x1, x2, y1=250, y2=429-50] = data;
							// console.log({x1, x2,y1,y2});
							thread_incrementers.add(i);

							child_state_transitions[i]?.push(() => {
								springTween(grandchild,
									{
										x1: +grandchild.getAttribute("x1"),
										y1: +grandchild.getAttribute("y1"),
										x2: +grandchild.getAttribute("x2"),
										y2: +grandchild.getAttribute("y2"),
									},
									{
										x1: +x1,
										y1: +y1,
										x2: +x2,
										y2: +y2,
									},
									{ stiffness, damping });
							});
						}
					}

					for (const i of thread_incrementers)
						child_state_transitions[i]?.unshift(() => my_thread.id++)
				}

				const unhide_slide = () => {
					// setTimeout(() => grandchild.removeAttribute("hidden"), 1000);
					grandchild.classList.remove("hide-slide");
					grandchild.classList.add("unhide-slide");
					grandchild.removeAttribute("hidden");
				};


				const hide_slide = () => {
					// console.log("hiding", grandchild);
					grandchild.classList.remove("unhide-slide");
					grandchild.classList.add("hide-slide");
					grandchild.setAttribute("hidden", "");


					// setTimeout(() => {
					// 	console.log({a:+click < +cur_click, b: +cur_click > (+click2 || -Infinity)})
					// 	if (!(+cur_click > (+click2 || -Infinity) || +click < +cur_click))
					// 		grandchild.setAttribute("hidden", "");
					// }, 1000);
				};

				child_state_transitions[clicky].push(unhide_slide);
				child_state_transitions[clicky - 1].push(hide_slide);

				if (click2) {
					child_state_transitions[click2]?.push(hide_slide);
					child_state_transitions[click2 - 1].push(unhide_slide);
				}
			}
			current_click_num = recursivelyHandleChildren(child_state_transitions, grandchild, current_click_num);
		}

		return current_click_num;
	}

	function countClicks(child, state) {
		for (const grandchild of child.children) {
			let click = grandchild.getAttribute("click")
			if (click !== null) {
				grandchild.setAttribute("hidden", "");
				const clicky = (click === "") ? ++state.current_click_num : parseInt(click) || 1;
				if (clicky > state.max_click_num) state.max_click_num = clicky;
			}
			countClicks(grandchild, state);
		}
		return state;
	}

	let IS_MOBILE_FULL_SCREEN = false;

	post_processes.push(() => {
		for (const [is_overlay, elements] of  [[false, slide_elements], [true, overlay_elements]]) {
			for (const [i, child] of elements.entries()) {
				child.setAttribute("hidden", "");
				const id = child.getAttribute("id");
				if (id === null) throw new Error("Please add an ID to slide " + i + ` (after the slide with an id of "${elements[i - 1].id}")`);
				const id_without_overlay = id.replace("-overlay", "");
				const click_attr = child.getAttribute("clicks");
				const num_clicks = is_overlay ? clicks.get(id_without_overlay) : parseInt(click_attr?.split(",").length > 1 ? click_attr.split(",").length + 1 : click_attr) ||
					(1 + countClicks(child, { current_click_num: 0, max_click_num: 0 }).max_click_num);

				console.log('a', num_clicks, child)

				clicks.set(id_without_overlay, num_clicks);
				const arr = slidesById.get(id_without_overlay) || [];
				arr.push(child);
				slidesById.set(id_without_overlay, arr);

				const child_state_transitions = is_overlay ? state_transitions.get(id_without_overlay) : new Array(num_clicks).fill(0).map(() => []);
				if (!is_overlay) state_transitions.set(id, child_state_transitions);

				child_state_transitions[0].push(() => {
					child.removeAttribute("hidden")
					if (i > 0) elements[i - 1].setAttribute("hidden", "")
					if (i < elements.length - 1) elements[i + 1].setAttribute("hidden", "")
					if (!is_overlay)
						container.setAttribute("viewBox", `0 0 1920 ${pane_heights.get(id) || 1080}`);
				});

				child_state_transitions[num_clicks - 1].push(() => {
					child.removeAttribute("hidden")
					if (i > 0) elements[i - 1].setAttribute("hidden", "")
					if (i < elements.length - 1) elements[i + 1].setAttribute("hidden", "")
				});

				// if (is_overlay)
				// 	state_transitions.get(id_without_overlay).forEach((a, i) => {
				// 		child_state_transitions.forEach((b, j) => {
				// 			console.log(a);
				// 			a.push(b);
				// 		});
				// 	});

				recursivelyHandleChildren(child_state_transitions, child, 0)
			}
		}
	});

				// 	global_scrolls.push({
				// 	section: slide_id,
				// 	slide_num: i + 1,
				// 	animation_duration,
				// 	pos: next,
				// });

	post_processes.push(() => {
		/**
		 * Create a cubic-bezier easing function.
		 * @param {number} p0x
		 * @param {number} p0y
		 * @param {number} p1x
		 * @param {number} p1y
		 */
		function cubicBezier(p0x, p0y, p1x, p1y) {
		// Helper functions for bezier math
		function cubic(a, b, m) { return ((1 - 3*b + 3*a) * m ** 3) + ((3*b - 6*a) * m ** 2) + (3*a * m); }
		function cubicDerivative(a, b, m) { return (3*(1 - 3*b + 3*a) * m ** 2) + (2*(3*b - 6*a) * m) + (3*a); }

		return function(t) {
			// Newton-Raphson iteration to find the parametric value for time t
			let x = t, i = 0;
			for (; i < 5; i++) {
			const xEstimate = cubic(p0x, p1x, x) - t;
			const dx = cubicDerivative(p0x, p1x, x);
			if (Math.abs(xEstimate) < 1e-6) break;
			x -= xEstimate / dx;
			}
			return cubic(p0y, p1y, x);
		};
		}

		// Your easing curve: cubic-bezier(0.69, 0.02, 0.53, 1)
		const easeCustom = cubicBezier(0.69, 0.02, 0.53, 1);

		/**
		 * Smooth scroll to target using cubic-bezier easing.
		 */
		let active_scroll_id = 0;
		function scrollToPosition(targetY, duration = 500) {
			const startY = window.scrollY;
			const distance = targetY - startY;
			let startTime = null;
			const my_scroll_id = ++active_scroll_id;

			function step(timestamp) {
				if (active_scroll_id !== my_scroll_id) return;
				if (!startTime) startTime = timestamp;
				const elapsed = timestamp - startTime;
				const progress = Math.min(elapsed / duration, 1);

				const easedProgress = easeCustom(progress);

				if (elapsed < duration) {
					window.scrollTo(0, startY + distance * easedProgress);
					requestAnimationFrame(step);
				} else {
					window.scrollTo(0, targetY);
				}
			}

			requestAnimationFrame(step);
		}

		let scroll_id = 0;

		function scrollElementOffsetAnimated(elem, offsetPx, duration = 500, section) {
			if (IS_MOBILE_FULL_SCREEN) return;
			let startTime = 0.0;
			const my_scroll_id = ++scroll_id;

			function step(timestamp) {
				if (cur_slide != section) return;
				if (my_scroll_id !== scroll_id) return;
				if (!startTime) startTime = timestamp;
				const elapsed = timestamp - startTime;
				const rect = elem.getBoundingClientRect();
				window.scrollTo(0, window.scrollY + rect.top - offsetPx);
				if (elapsed < duration) requestAnimationFrame(step);
			}

			requestAnimationFrame(step);
		}


		{
			let i = 0;
			const selectors = new Set();
			const sections = new Set();

			const positions = global_scrolls.map(({ pos }) => 120 - pos * 80 - 55);

			for (const [i, { section, slide_num, animation_duration, selector, pos, do_not_move_mobile }] of global_scrolls.entries()) {
				// console.log({ section, slide_num, animation_duration, selector, pos });
				if (do_not_move_mobile) continue;

				// console.log({selector:selector.slice(0, -("-rect".length))});
				sections.add(section);
				selectors.add(selector);

				global_animations.push({
					section,
					selector: selector.slice(0, -("-rect".length)),
					slide_num,
					animation_duration,
					forward_only: true,
					keyframes: {
						0:    {  transform: `translateY(${positions[i - 1] || 0}px)` },
						100:   { transform: `translateY(${positions[i]}px)` },
					},
					mobile_full_screen_only: true,
				});

				global_animations.push({
					section,
					selector: selector.slice(0, -("-rect".length)),
					slide_num,
					animation_duration: global_scrolls[i+1]?.animation_duration,
					backward_only: true,
					keyframes: {
						0:    {  transform: `translateY(${positions[i + 1] || 0}px)` },
						100:   { transform: `translateY(${positions[i]}px)` },
					},
					mobile_full_screen_only: true,
				});

				console.log({section, slide_num, len: state_transitions.get(section).length })
				state_transitions.get(section)[slide_num].push(() => {
					const elem = document.querySelector(selector);
					const styles = getComputedStyle(elem);

					// console.log("selector", selector);
					// console.log("elem", elem);
					// console.log("styles.animationDuration", styles.animationDuration);

					scrollElementOffsetAnimated(document.querySelector(selector),
						// offset from top
						70,
						1000 * styles.animationDuration.slice(0, -1), section);
				});

			}

			const selectors_arr = [...selectors];
			const sections_arr = [...sections];

			for (let i = 0; i < selectors_arr.length; i++)
				state_transitions.get(sections_arr[i])[0].push(() => {
					scrollElementOffsetAnimated(document.querySelector(selectors_arr[i]),
								// offset from top
								70,
								5000, sections_arr[i]);
				});
		}

		// console.log(global_scrolls);
	})

	const code_info = new Map();

	let code_block_i = 0;

	for (const codeblock of document.getElementsByClassName("code")) {
		let codeblock_id = codeblock.getAttribute("id");
		const x = +codeblock.getAttribute("x");
		const y = +codeblock.getAttribute("y");
		const steps = codeblock.getAttribute("steps");
		const do_not_move_mobile = codeblock.hasAttribute("do-not-move-mobile");
		const mini_steps = codeblock.getAttribute("mini-steps");
		const lang = codeblock.getAttribute("lang");
		const width = +codeblock.getAttribute("width");
		const click = +codeblock.getAttribute("click");
		if (codeblock.getAttribute("height")) {
			throw new Error("Height is not allowed on code block")
		}
		const line_height = +codeblock.getAttribute("line-height");
		const font_size = codeblock.getAttribute("font-size") || "";
		const letter_spacing = codeblock.getAttribute("letter-spacing") || "";

		const line_num_indent = +codeblock.getAttribute("line-num-indent");
		const hide_line_numbers = codeblock.hasAttribute("hide-line-numbers");

		const line_indent = +codeblock.getAttribute("line-indent");
		let slide = codeblock;
		do slide = slide.parentNode; while (!slide.classList.contains("slide"));
		const slide_id = slide.getAttribute("id");


		const [lines, ranges] = preprocess(slide_id, codeblock.innerHTML, lang);

		if (codeblock_id) {
			code_info.set(codeblock_id, { x, y, width, line_height, line_num_indent, hide_line_numbers, line_indent, slide, ranges });
		} else {
			codeblock_id = `${slide_id}-codeblock-${code_block_i++}`;
			codeblock.setAttribute("id", codeblock_id);
		}

		if (lines.length > 0) {
			let innerHTML = codeblock.hasAttribute("hide-background") ? '' : `<rect x="${x || 0}" y="${y || 0}" height="${y + (line_height*(codeblock.getAttribute("lines") || lines.length)) + 20}" width="${width}" fill="black"></rect>`;
			innerHTML += lines.map((e, i) => `<text class="line-of-code" line-no="${i-1}" x="${x + line_indent}" y="${y + (line_height*(i+1))}">${e}</text>`).join('\n');

			if (!hide_line_numbers)
				innerHTML += lines.map((_, i) => `<text class="line-number" x="${x + line_num_indent}" y="${y + (line_height*(i+1)) - 1}" text-anchor="end">${i + 1}</text>`);

			const extra_height = y + (line_height*(lines.length));
			const [body] = document.getElementsByTagName("body");
			if (extra_height > 1080) {
				pane_heights.set(slide_id, extra_height);

				body.insertAdjacentHTML("beforeend",
					`
					<style>
					#container[slide="${slide_id}"] {
					height: ${extra_height / 10.80}%
					}
					</style>
				`);
			}

			if (font_size || letter_spacing) {
				body.insertAdjacentHTML("beforeend", `
				<style>
				#${codeblock_id} text.line-of-code {
					${font_size && `font-size: ${font_size};`}
					${letter_spacing && `letter-spacing: ${letter_spacing};`}
				}
				</style>
				`);
			}

			codeblock.innerHTML = innerHTML;
		}


		const colors = ["rgb(0, 100, 0)", "purple", "rgb(130, 0, 0)", "rgb(88, 0, 158)", "rgb(0, 0, 200)"];

		if (mini_steps) {
// <svg width="300" height="120" viewBox="0 0 300 120" xmlns="http://www.w3.org/2000/svg">


//   <!-- visible frame for reference -->
//   <rect x="10" y="10" width="200" height="80" fill="none" stroke="#333"/>

//   <!-- anything inside this group will be clipped to the rect above -->
//   <defs>
//     <clipPath id="boxClip" clipPathUnits="userSpaceOnUse">
//       <!-- rectangle that defines the clipping box -->
//       <rect x="10" y="10" width="200" height="80" rx="8"/>
//     </clipPath>
//   </defs>
//   <g clip-path="url(#boxClip)">
//     <!-- content that extends beyond the rect -->
//     <rect x="0" y="0" width="260" height="120" fill="lightblue"/>
//     <text x="20" y="60" font-size="28">This gets clipped →</text>
//   </g>
// </svg>

			codeblock.innerHTML = `
			<defs>
			  <clipPath id="${codeblock_id}-clipper" clipPathUnits="userSpaceOnUse">
			    <rect x="${x}" y="${y}" width="${1920-x}" height="${1250}"/>
			  </clipPath>
			</defs>
			<g clip-path="url(#${codeblock_id}-clipper)">
			<g id="${codeblock_id}-translator">
			<rect id="${codeblock_id}-box" width="700"></rect>
			${codeblock.innerHTML}
			</g>
			</g>`;

			let last_translation = 0;
			let last_height = 0;
			let last_x = x + 40;
			let last_y = y;

			const mini_step_data = mini_steps.split(',').map((str, i) => {
				let [line, len] = str.split(':');
				len = i && +(len || 1);
				line = +line;

				return {
					prev_y: last_translation,
					y: last_translation = -line_height * Math.max(0, line - 4) - 10,
					prev_height: last_height,
					height: last_height = line_height * len,

					prev_box_y: last_y,
					box_y: last_y = y + line_height * (line + 1) + 10,

					prev_color: colors[(click + i + 4) % colors.length],
					color: colors[(click + i + 5) % colors.length],
				};
			});

			mini_step_data.push({
				prev_y: y,
				y: y,
				prev_height: 0,
				height: 0,

				prev_box_y: y,
				box_y: y,

				prev_color: colors[(click + mini_step_data.length + 0) % colors.length],
				color: colors[(click + mini_step_data.length + 1) % colors.length],
			});

			Array.prototype.push.apply(global_animations, mini_steps.split(',').map((str, i) => {
				let [line, len] = str.split(':');
				len = +len || 0;
				line = +line;

				const current_step = mini_step_data[i];
				const next_step = mini_step_data[i + 1];
				const animation_duration = i !== 0 ? "0.25s" : "2s";

				return [{
					section: slide_id,
					selector: `#${codeblock_id}-translator`,
					slide_num: click + i,
					forward_only: true,
					skip_auto_prev_state: true,
					animation_delay: i ? "0s" : "1s",
					animation_duration: i !== 0 ? "0.25s" : "2s",
					keyframes: {
						0:   { transform: `translateY(${current_step.prev_y}px)` },
						100: { transform: `translateY(${current_step.y}px)` },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-box`,
					slide_num: click + i,
					forward_only: true,
					skip_auto_prev_state: true,
					animation_delay: i ? "0s" : "1s",
					animation_duration: i !== 0 ? "0.25s" : "2s",
					keyframes: {
						0:   { height: `${current_step.prev_height}px`, fill: current_step.prev_color, x: last_x, y: current_step.prev_box_y },
						100: { height: `${current_step.height}px`, fill: current_step.color, x: last_x, y: current_step.box_y },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-translator`,
					slide_num: click + i,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration: "0.25s",
					keyframes: {
						0:   { transform: `translateY(${next_step.y}px)` },
						100: { transform: `translateY(${current_step.y}px)` },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-box`,
					slide_num: click + i,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration: "0.25s",
					keyframes: {
						0:   { height: `${next_step.height}px`, fill: next_step.color, x: last_x, y: next_step.box_y },
						100: { height: `${current_step.height}px`, fill: current_step.color, x: last_x, y: current_step.box_y },
					}
				}];
			}).flat());

		}

		if (steps) {
			codeblock.insertAdjacentHTML("afterbegin", `<rect id="${codeblock_id}-rect" width="1950" fill="purple" style="opacity: 0.6"></rect>`)
			let last = 0;
			let last_height = "0px";
			let last_y = "0px";

			Array.prototype.push.apply(global_animations, steps.split(",").map((av, i, k) => {
				const isLast = k.length === i + 1;
				let [v, num_lines] = av.split(":");
				num_lines ||= '1';
				const prev = last;

				// (8 - num_lines)
				// 2076

				const next = last = Math.min(0, (-v + Math.max(2, 3 - num_lines)) * line_height) - 9;
				let anim_duration = Math.max(0.2, Math.abs(next - prev) / (10000));
				if (anim_duration > 1) {
					anim_duration = 2;
				}
				const animation_duration = `${(i === 0 ? 1/0.9 : 1.25) * anim_duration}s`;
				// console.log({ prev, next, animation_duration });
				// console.log([v, y + (line_height*(v - 1)) + 10]);

				const prev_height = last_height;
				const next_height = last_height = `${line_height*(num_lines || 1) + line_height / 7}px`;

				const prev_y = last_y;
				const next_y_num = y + (line_height*(v - 1)) + line_height / 7;
				const next_y = last_y = `${next_y_num}px`;

				global_scrolls.push({
					section: slide_id,
					slide_num: i + 1,
					animation_duration,
					linear: true,
					pos: +v,
					selector: `#${codeblock_id}-rect`,
					do_not_move_mobile,
				});

				// console.log({codeblock_id,v,animation_duration,prev_height, prev_y, next_height, next_y})


				return [

				// {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i + 1,
				// 	forward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${prev}px)` },
				// 		100: { transform: `translateY(${next}px)` },
				// 	}
				// }, {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i,
				// 	backward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${next}px)` },
				// 		100: { transform: `translateY(${prev}px)` },
				// 	}
				// },
				{
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i + 1,
					forward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: prev_height, y: prev_y, fill: colors[(click + i + 0) % colors.length] },
						90: i === 0 ? { y: next_y, height: 0 } : undefined,
						100: { height: next_height, y: next_y, fill: colors[(i + 1) % colors.length] },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: next_height, y: next_y, fill: colors[(click + i + 1) % colors.length] },
						10: i === 0 ? { height: 0 } : undefined,
						100: { height: prev_height, y: prev_y, fill: colors[(click + i + 0) % colors.length] },
					}
				}, isLast && {
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i + 1,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: next_height, y: next_y },
						90: i === 0 ? { y: next_y, height: 0 } : undefined,
						100: { height: next_height, y: next_y },
					}
				},
				// isLast && {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i + 1,
				// 	backward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${next}px)` },
				// 		100: { transform: `translateY(${next}px)` },
				// 	}
				// }
			];
			}).flat())
		}
	}

	for (const text of [...document.getElementsByTagName("text")]) {
		const align = text.getAttribute("align");
		if (align) {
			const line = +text.getAttribute("line");
			const info = code_info.get(align);

			text.setAttribute("x", info.x + info.line_indent);
			text.setAttribute("y", info.y + (info.line_height*(line+1)));

			for (const cl of ["label", "small-label", "xsmall-label", "ysmall-label", "big-label"]) {
				const label = text.getAttribute(cl);

				if (label) {
					const click = text.getAttribute("click");
					text.insertAdjacentHTML("beforebegin", `<text id="${text.getAttribute("id")}-label" class="${cl}" ${click ? `click=${click}` : ""} text-anchor="end" x="${info.x + info.line_indent}" y="${info.y + (info.line_height*(line+1))}">${label.replaceAll(">>", "»").replaceAll("<<", "«")}${label.length === 1 ? '' : `:`}&nbsp;</text>`)
				}
			}
		}
	}

	for (const bits of document.getElementsByClassName("bits-auto-color")) {
		bits.innerHTML = bits.innerHTML.replaceAll(/1+/g, e => `<tspan class="bit-1">${e}</tspan>`);
	}

	// const indexToChar = new Array(64).fill('').map((_, i) => i < 62 ? i < 36 ? i.toString(36) : (i - 26).toString(36).toUpperCase() : '&$'[i - 62]);


	for (const bits of document.getElementsByClassName("bits-match-color")) {
		const align = bits.getAttribute("align");
		if (!align) throw new Error("bits-match-color must use the 'align' property to be paired up with something!")
		const info = code_info.get(align);
		// console.log(bits.innerHTML);
		bits.innerHTML = processRanges(info.ranges, bits.innerHTML).join('\n');
	}

	{
		let i = 0;
		for (const bits of document.getElementsByClassName("bits-match-color2")) {
			const align = bits.getAttribute("align");
			if (!align) throw new Error("bits-match-color2 must use the 'align' property to be paired up with something!")
			const info = code_info.get(align);

			const [smally] = bits.getElementsByClassName("bits-small")

			for (const [kind, bottom, top] of info.ranges) {
				if (bottom <= i && i < top) {
					smally.classList.add("code-" + kind);
					break;
				}
			}
			// bits.innerHTML = processRanges(info.ranges, bits.innerHTML).join('\n');
			i++;
		}
	}

	for (const post_process of post_processes) post_process();

	const all_styles = new Map();

{
	let i = 0;
	let styles = new Array();
	let prev_selector;
	let prev_slide_num;
	let prev_section;
	let prev_mobile_full_screen_only;
	const animations = new Array();

	function getSelectorForInternal(ge, num_clicks) {
		if (ge === num_clicks) throw new Error("num_clicks must be higher than the target click (clicks start at 0)")
		let arr = [];
		let y = ge;
		for (; y % 10; y++) {
			if (y >= num_clicks) return arr;
			arr.push(`[click="${y}"]`);
		}

		let z = y;
		let i = -1;
		for (; z % 100; z += 10) {
			if (z >= num_clicks) return arr;
			if (z / 10 === ge) {
				for (; z % 100; z += 10) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 10}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			arr.push(`[click^="${z / 10}"]:not([click="${z / 10}"])`);
		}

		let q = z;
		i = -1;
		for (; z % 1000; z += 100) {
			if (z >= num_clicks) return arr;
			// console.log(z, ge)
			if (z / 100 === ge) {
				for (; z % 1000; z += 100) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 100}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			for (let j = 0; j < 10; j++) {
				const k = z / 10 + j;

				arr.push(`[click^="${k}"]${ge <= k && k < num_clicks ? '' : `:not([click="${k}"])`}`);
			}
		}

		return arr;
	}

	function getSelectorFor(ge, num_clicks) {
		return `:is(${getSelectorForInternal(+ge, +num_clicks).join(", ")})`;
	}

	function getSelectorForRangeInternal(num_clicks, ge, lt) {
		if (ge === num_clicks) throw new Error("num_clicks must be higher than the target click (clicks start at 0)")
		let arr = [];
		let y = ge;
		for (; y % 10; y++) {
			if (y >= num_clicks) return arr;
			arr.push(`[click="${y}"]`);
		}

		let z = y;
		let i = -1;
		for (; z % 100; z += 10) {
			if (z >= num_clicks) return arr;
			if (z / 10 === ge) {
				for (; z % 100; z += 10) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 10}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			arr.push(`[click^="${z / 10}"]:not([click="${z / 10}"])`);
		}

		let q = z;
		i = -1;
		for (; z % 1000; z += 100) {
			if (z >= num_clicks) return arr;
			// console.log(z, ge)
			if (z / 100 === ge) {
				for (; z % 1000; z += 100) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 100}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			for (let j = 0; j < 10; j++) {
				const k = z / 10 + j;

				arr.push(`[click^="${k}"]${ge <= k && k < num_clicks ? '' : `:not([click="${k}"])`}`);
			}
		}

		return arr;
	}

	function getSelectorForRange(num_clicks, ge, lt) {
		return `:is(${getSelectorForRangeInternal(+num_clicks, +ge, +lt).join(", ")})`;
	}

	// console.log(getSelectorFor('5', '23'));
	// console.log(getSelectorFor('23', '33'));
	// console.log(getSelectorFor('20', '30'));

	const elements_to_selectors = new Map();
	const selectors_to_keyframes = new Map();

	for (const { section = (() => { throw "Invalid section" })(), selector, slide_num, keyframes } of global_animations.filter(e => e)) {
		const start_keyframe = keyframes[0];
		const end_keyframe = keyframes[100];

		for (const [, individual_selector] of selector.matchAll(/([^,]+?)(?:, ?|$)/g)) {
			for (const element of document.querySelectorAll(individual_selector)) {
				const old = elements_to_selectors.get(element);
				if (old && old !== individual_selector) {
					throw new Error("Cannot make an object peacefully coexist in two different classes/ids. Please use id's instead. Conflict between `" + individual_selector + "` and `" + old + "`");
				} else {
					elements_to_selectors.set(element, individual_selector);
				}
			}

			let arr = selectors_to_keyframes.get(individual_selector);
			if (arr === undefined) {
				arr = new Array();
				selectors_to_keyframes.set(individual_selector, arr);
			}
			arr.push({ slide_num, start_keyframe, end_keyframe });
		}
	}

	for (const [i, v] of selectors_to_keyframes.entries()) {
		let prev_slide_num = 0;

		for (const { slide_num, start_keyframe, end_keyframe } of v.sort((a, b) => a.slide_num - b.slide_num)) {
			// prev_slide_num, slide_num, new Array(slide_num - prev_slide_num).fill().map((_, i) => i + prev_slide_num);
			// console.log(slide_num, prev_slide_num);
			prev_slide_num = slide_num;
		}
	}

	//
	for (const { section, selector, slide_num, keyframes, animation_delay = '0s', animation_duration = '0s', skip_auto_prev_state = section === prev_section && selector === prev_selector, forward_only = false, backward_only = false, ease = false, linear = false, continuous = false, mobile_full_screen_only = false } of global_animations.filter(e => e)) {
		if (section !== (prev_section ?? section)) {
			all_styles.set(prev_section, styles.join("\n"));
			styles = [all_styles.get(section) ?? ""] ?? new Array();
		}
		i += 1;
		const old_styles_len = styles.length;
		const keyframe_entries = Object.entries(keyframes).filter(e => e[1] !== undefined).map(([a, b]) => [+a, b]).sort((a, b) => a[0] - b[0]);
		if (keyframe_entries[0]?.[0] !== 0) throw "Missing keyframe 0";
		if (keyframe_entries[keyframe_entries.length - 1]?.[0] !== 100) throw "Missing keyframe 100";

		if (selector !== prev_selector || slide_num !== prev_slide_num || mobile_full_screen_only !== prev_mobile_full_screen_only) {
			animations.length = 0;
		}

		const animation = `animation${i} ${animation_duration} ${linear ? "linear" : ease === true ? "ease" : ease || "cubic-bezier(0.69, 0.02, 0.53, 1)"} ${animation_delay} 1 forwards normal`;
		animations.push(animation)

		const mobile_only = mobile_full_screen_only ? "#container[mobile-translate] " : ""
		let selectors = selector.split(',');

		if (!skip_auto_prev_state) {
			styles.push(`${mobile_only}.slide#${section} ${selector} {
		${Object.entries(keyframe_entries[0][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	}`);
		}


		// if (selector.startsWith('.')) {
		// 	Array.prototype.push.apply(selectors, [...document.querySelectorAll(selector)].filter(x => x.id).map(x => `${selector}#${x.id}`));
		// }

		styles.push(`${selectors.map(selector => `${mobile_only}.slide#${section}[${continuous ? 'fragment-' : 'click="'}${slide_num}${continuous ? '' : '"'}]${forward_only ? "[present-went-forward]" : backward_only ? "[present-went-backward]" : ""} ${selector}`).join(',\n')} {
		animation: ${animations.join(",\n\t")};
	}`);

		if (!continuous) styles.push(`${selectors.map(selector => `${mobile_only}.slide#${section}[fragment-${slide_num + 1}] ${selector}`).join(',\n')} {
		${Object.entries(keyframe_entries[keyframe_entries.length - 1][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	}`);

	// 	if (forward_only) styles.push(`${`${selectors.map(selector => `.slide#${section}[click="${slide_num}"][present-went-backward] ${selector}`).join(',\n')} {
	// 	${Object.entries(keyframe_entries[keyframe_entries.length - 1][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	// }`}`);

		styles.push(`@keyframes animation${i} {
		${keyframe_entries.map(([a, b]) => `${a}% { ${Object.entries(b).map(([a, b]) => `${a}: ${b};`).join(" ")} }`).join("\n\t")}
	}`);

		if (mobile_full_screen_only) {
			// for (let n = old_styles_len; n < styles.length; n++)
				// console.log(styles[n]);
			// console.log(styles[styles.length - 1]);
		}

		prev_selector = selector;
		prev_slide_num = slide_num;
		prev_section = section;
		prev_mobile_full_screen_only = mobile_full_screen_only;
	}

	all_styles.set(prev_section, styles.join("\n"));

	var styleSheet = document.createElement("style");
	styleSheet.id = "slide-animations";
	styleSheet.innerHTML = [...all_styles.values()].join('\n');
	document.head.appendChild(styleSheet);
}

	const getStateFromURL = () => {
		const slide_arg = window.location.href.split("#").pop();
		const [slide_title, clicks_amt] = slide_arg.split("?");
		let cur_slide = slide_title || slide_elements[0].id;
		if (!clicks.has(cur_slide)) [[cur_slide]] = clicks;

		return [
			cur_slide,
			(clicks_amt || "").startsWith("click=")
			? Math.min(clicks.get(cur_slide) - 1, parseInt(clicks_amt.slice("click=".length)) || 0)
			: 0
		];
	}

	let [cur_slide, cur_click] = getStateFromURL();

	const updateURL = () => window.location.href = "#" + cur_slide + (cur_click === 0 ? '' : `?click=${cur_click}`);

	const updateContainerSlideAttribute = () => {
		container.setAttribute("slide", cur_slide);
		overlay.setAttribute("slide", cur_slide + "-overlay");
	}


	// window.onhashchange = function() {
	// 	const targetState = getSlideFromURL();
	// 	setState(targetState)
	// };

	function applyTransitions() {
		for (const cur_slide_element of slidesById.get(cur_slide)) {
			cur_slide_element.setAttribute("click", "" + cur_click);
			for (let i = 0; i <= cur_click; i++) cur_slide_element.setAttribute(`fragment-${i}`, "");
			const max_clicks = clicks.get(cur_slide);
			for (let i = cur_click; ++i < max_clicks; ) cur_slide_element.removeAttribute(`fragment-${i}`);
		}

		for (const state_transition of state_transitions.get(cur_slide)[cur_click]) {
			state_transition();
		}
	}

	function applyStateTransitionsUpToCurrentClickInSlide() {
		for (let i = 0; i <= cur_click; i++) {
			for (const state_transition of state_transitions.get(cur_slide)[i]) {
				state_transition();
			}
		}
	}

	function nextSlide() {
		let next_slide;
		let wasPreviousCurrentSlide = false;
		for (const [slide] of clicks) {
			if (wasPreviousCurrentSlide) {
				next_slide = slide;
				break;
			}
			wasPreviousCurrentSlide = cur_slide === slide;
		}
		if (!next_slide) return false;
		for (const cur_slide_element of slidesById.get(cur_slide)) {
			for (let i = 0; i < cur_click; i++) {
				cur_slide_element.removeAttribute(`fragment-${i}`);
			}
			cur_slide_element.removeAttribute("click");
			cur_click = 0;
		}

		cur_slide = next_slide;
		updateContainerSlideAttribute();
		return true;
	}

	function goForward() {
		const old_slide = cur_slide;
		const max_click = clicks.get(cur_slide) - 1;
		cur_click++;
		let is_new_slide = true;
		if (cur_click > max_click) {
			is_new_slide = nextSlide();
			if (!is_new_slide)
				cur_click--;
		}
		for (const old_slide_element of slidesById.get(old_slide)) {
			old_slide_element.removeAttribute("present-went-backward");
			if (old_slide !== cur_slide) old_slide_element.removeAttribute("present-went-forward");
		}
		for (const cur_slide_element of slidesById.get(cur_slide)) cur_slide_element.setAttribute("present-went-forward", "");
		if (is_new_slide) {
			applyTransitions();
			updateURL();
		}
	}

	function prevSlide() {
		for (const slide of slidesById.get(cur_slide)) {
			slide.removeAttribute("click");
			slide.removeAttribute("fragment-0");
		}
		let [[previous_slide]] = clicks
		for (const [slide] of clicks) {
			if (cur_slide === slide) break;
			previous_slide = slide;
		}
		cur_slide = previous_slide;
		cur_click = clicks.get(cur_slide) - 1;
		applyStateTransitionsUpToCurrentClickInSlide();
		updateContainerSlideAttribute();
	}

	function goBackward() {
		const old_slide = cur_slide;

		if (cur_click === 0) {
			prevSlide();
		} else {
			cur_click--;
		}

		for (const old_slide_element of slidesById.get(old_slide)) {
			old_slide_element.removeAttribute("present-went-forward");
			if (old_slide !== cur_slide) old_slide_element.removeAttribute("present-went-backward");
		}
		for (const slide of slidesById.get(cur_slide)) slide.setAttribute("present-went-backward", "");

		applyTransitions();
		updateURL();
	}

	let is_control_depressed = false;

	window.addEventListener("touchend", () => {
		document.body.requestFullscreen({ navigationUI: "hide" })
		.then(() => {
			IS_MOBILE_FULL_SCREEN = true;
			container.setAttribute("mobile-translate", "");
		})
		.catch(err => {
			console.error("Fullscreen request failed:", err);
		});
	});
	// window.addEventListener("touchstart", () => void (document.querySelector("body").requestFullscreen({ navigationUI: "hide" })));
	window.addEventListener("keyup", function (event) {
		// Do nothing if the event was already processed
		if (event.defaultPrevented) return;
		switch (event.key) {
		case "Control":
			is_control_depressed = false;
			break;
		default:
			return; // Quit when this doesn't handle the key event.
		}
	});

	window.addEventListener("keydown", function (event) {
		// Do nothing if the event was already processed
		if (event.defaultPrevented) return;

		switch (event.key) {
		case "ArrowLeft":
			goBackward();
			break;
		case "ArrowRight":
			goForward();
			break;
		case "Control":
			is_control_depressed = true;
			break;
		case 'c':
			if (is_control_depressed) {
				navigator.clipboard.writeText(code_snippets.get(cur_slide));
			}
		default:
			return; // Quit when this doesn't handle the key event.
		}

		// Cancel the default action to avoid it being handled twice
		event.preventDefault();
	}, true);

	applyTransitions();
	updateURL();
	applyStateTransitionsUpToCurrentClickInSlide();
	updateContainerSlideAttribute();
	for (const slide of slidesById.get(cur_slide)) slide.setAttribute("present-went-forward", "");
</script>


<script>
function subtractBinary(a, b) {
    // Convert binary strings to integers
    const intA = BigInt(`0b${[...a.replaceAll('.', '0')].reverse().join('')}`);
    const intB = BigInt(`0b${[...b.replaceAll('.', '0')].reverse().join('')}`);

    // Subtract
    let result = intA - intB;
	const flip_around = result < 0n;

    // If negative, handle appropriately
    if (flip_around) {
        result = ~result;
    }

	let str = result.toString(2).padStart(64, '0');

	if (flip_around) {
        str = str.replaceAll(/[01]/g, e => ['1', '0'][+e]);
    }

    // Convert back to binary string
    return [...str.replaceAll('0', '.')].reverse().join('');
}

function opBinary(a, b, op) {
    // Convert binary strings to integers
    const intA = BigInt(`0b${[...a.replaceAll('.', '0')].reverse().join('')}`);
    const intB = BigInt(`0b${[...b.replaceAll('.', '0')].reverse().join('')}`);

    // Subtract

    let result = undefined;

	switch (op) {
		case '-': result = intA - intB; break;
		case '^': result = intA ^ intB; break;
		case '&': result = intA & intB; break;
		case '&~': result = intA & ~intB; break;
		case '|': result = intA | intB; break;
	}

	const flip_around = result < 0n;

    // If negative, handle appropriately
    if (flip_around) {
        result = ~result;
    }

	let str = result.toString(2).padStart(64, '0');

	if (flip_around) {
        str = str.replaceAll(/[01]/g, e => ['1', '0'][+e]);
    }

    // Convert back to binary string
    return [...str.replaceAll('0', '.')].reverse().join('');
}

// Example:
const even_series = opBinary(
	"0111.111.1..1111.1.11111.11111.111111111.11111.1111.1111111111.1",
	"11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11", '-');

const esc_and_term = opBinary(even_series, '.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1', '^');
const escaped = opBinary(esc_and_term, "11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11", "^");
// console.log(even_series);
// console.log(esc_and_term);
// console.log(escaped);

// console.log(opBinary(
// 	"1....1.....1...11...1.1..1.......11............11............1..",
// 	"1...............1.................1..............1..............", "-"));

// const starts_and_quote_bounds = opBinary("...............1.................1..............1...............", opBinary("1..........1....1.....1........................1................", opBinary("...............1.................1..............1...............",
// opBinary("1...............1.................1..........................1.." & "1..........1....1.....1........................1................", "&"), '-'), '&'), '|');

const starts = "1...............1.................1..........................1..";
const quote_bounds_incl_carry = "1..........1....1.....1........................1................";
const starts_and_quote_bounds = opBinary(starts, quote_bounds_incl_carry, '&');
const carriages_or_newlines_or_eof = "...............1.................1..............1...............";
const subbed = opBinary(carriages_or_newlines_or_eof, starts_and_quote_bounds, '-');
const imm = opBinary(quote_bounds_incl_carry, subbed, '&');
let imm2 = opBinary(carriages_or_newlines_or_eof, imm, '|');
imm2 = opBinary(imm2, starts, '&~');

const cur_ends = opBinary(imm2, opBinary(imm2, starts, '-'), '&~');


// console.log({cur_ends});

</script>

<style>
	.bits-small {
		font-size: 25px;
		letter-spacing: -2px;
		text-align: center;
	}
</style>

</body>
</html>
