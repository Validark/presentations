<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="utf-8">
	<title>Frequency Capping</title>
	<link rel="stylesheet" type="text/css" href="./fonts/Iosevka/Iosevka.css">
	<style>
		[hidden] {
		  display: none;
		}

		g.slide:not([hidden]) > .h2:first-child:not(.code),
		g.slide:not([hidden]) > [click]:not([hidden]):not(.no-slide-in):not(.no-slide-in2):not(.code),
		g.slide:not([hidden]) > [click]:not([hidden]):not(.code) text:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > [click]:not([hidden]):not(.code) tspan:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg):not(.code) text:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg):not(.code) tspan:not(.highlighted):not(.highlighted-blue),

		g.slide:not([hidden]) > g:not(.no-slide-in) > .h2:first-child:not(.code),
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]):not(.no-slide-in):not(.no-slide-in2):not(.code),
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]):not(.code) text:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]):not(.code) tspan:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg):not(.code) text:not(.highlighted):not(.highlighted-blue),
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg):not(.code) tspan:not(.highlighted):not(.highlighted-blue)
		{
			animation: unhide 0.5s cubic-bezier(0, 0, 0.53, 1) 0s 1 forwards;
		}


		g.slide:not([hidden]) > [click]:not([hidden]) text.highlighted,
		g.slide:not([hidden]) > [click]:not([hidden]) tspan.highlighted,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) text.highlighted,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) tspan.highlighted,
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]) text.highlighted,
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]) tspan.highlighted,
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg) text.highlighted,
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg) tspan.highlighted
		{
			animation: unhide-highlighted 0.5s cubic-bezier(0, 0, 0.53, 1) 0s 1 forwards;
		}

		g.slide:not([hidden]) > [click]:not([hidden]) text.highlighted-blue,
		g.slide:not([hidden]) > [click]:not([hidden]) tspan.highlighted-blue,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) text.highlighted-blue,
		g.slide:not([hidden]) > :first-child:not([hidden]):not(svg) tspan.highlighted-blue,
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]) text.highlighted-blue,
		g.slide:not([hidden]) > g:not(.no-slide-in) > [click]:not([hidden]) tspan.highlighted-blue,
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg) text.highlighted-blue,
		g.slide:not([hidden]) > g:not(.no-slide-in) > :first-child:not([hidden]):not(svg) tspan.highlighted-blue,
		g.slide > g > text > tspan > tspan.highlighted-blue
		{
			animation: unhide-highlighted-blue 0.5s cubic-bezier(0, 0, 0.53, 1) 0s 1 forwards;
		}

		g.slide:not([hidden]) {
			animation: unhide-slide 0.5s ease 0s 1 forwards;
		}

		.unhide-slide:not(.no-slide-in):not(.no-slide-in2) {
			animation: unhide-slide 0.5s ease 0s 1 forwards;
		}

		.unhide-slide.no-slide-in {
			animation: no-unhide-slide 0.5s ease 0s 1 forwards;
		}

		.unhide-slide.no-slide-in2 {
			animation: no-unhide-slide2 0.5s ease 0s 1 forwards;
		}

		.hide-slide {
			animation: hide-slide 0.5s ease 0s 1 forwards;
		}


		@keyframes unhide {
			0%   { transform: translateY(-60px); stroke: rgba(255, 255, 255, 1); stroke-width: 5px; }
			100% { transform: translateY(0); stroke: rgba(255, 255, 255, 0) }
		}

		@keyframes unhide-highlighted {
			0%   { transform: translateY(-60px); stroke: rgba(255, 255, 255, 1); stroke-width: 5px; }
			100% { transform: translateY(0); stroke: rgba(0, 255, 255, 1); stroke-width: 2px; }
		}

		@keyframes unhide-highlighted-blue {
			0%   { transform: translateY(-60px); stroke: rgba(255, 255, 255, 1); stroke-width: 5px; }
			100% { transform: translateY(0); stroke: rgb(255, 177, 100); stroke-width: 2px; }
		}

		@keyframes unhide-slide {
			from   { transform: translateY(-60px); }
		}

		@keyframes no-unhide-slide {
			from   { transform: translateY(60px); }
		}

		@keyframes no-unhide-slide2 {
			/* from   { transform: translate(150px, -550px) rotate(45deg); } */
		}

		@keyframes hide-slide {
			to   { transform: translateY(-60px); opacity: 0; }
		}

		g.slide#title {
			animation: unhide-svg 10s cubic-bezier(0, 1, 0, 1) 0s 1 forwards !important;
		}

		@keyframes unhide-svg {
			0%   { transform: scale(0) translate(1100px, 1600px); }
			100% { transform: scale(1) translate(0, 0); }
		}

		@font-face {
			font-family: 'Press Start 2P';
			src: url('./fonts/Press_Start_2P/PressStart2P-Regular.ttf') format('truetype');
			font-weight: 400;
			font-style: normal;
			font-display: block;
		}

		@font-face {
			font-family: 'Ysabeau Office';
			src: url('./fonts/Ysabeau_Office/static/YsabeauOffice-Regular.ttf') format('truetype');
			font-weight: 400;
			font-style: normal;
			font-display: block;
		}

		@font-face {
			font-family: 'Ysabeau Office';
			src: url('./fonts/Ysabeau_Office/static/YsabeauOffice-Medium.ttf') format('truetype');
			font-weight: 500;
			font-style: normal;
			font-display: block;
		}

		* {
			padding: 0;
			margin: 0;
			box-sizing: border-box;
		}

		html, body, #container, #overlay {
			height: 100%;
			width: 100%;
			font-size: 12pt
		}

		.h1, .h2, .h3, .h4 {
			font-family: "Press Start 2P";
			color: hsl(265, 89%, 78%);
			text-align: center;
			line-height: 1.25;
			letter-spacing: -1px;
		}

		.h2, .h3, .h4 {
			fill: hsl(265, 89%, 78%);
		}

		h1, .h1 {
			font-size: 8rem;
		}

		h2, .h2 {
			font-size: 4.25rem;
		}

		.h3 {
			font-size: 2.75rem;
		}

		.h4 {
			font-size: 2rem;
		}

		#container, #overlay {
			height: 100%;
			width: 100%;
			position: absolute;
			background-color: #000
			/* animation: container-background 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0s 1 forwards; */
		}

		#overlay {
			position: fixed;
			background: none;
		}

		@keyframes container-background {
			0% { background-color: hsl(231, 15%, 18%) }
			100%   { background-color: #000 }
		}

		/* .slide {
			padding-top: 1in;
			padding-bottom: 1in;
			padding-left: 1in;
			padding-right: 1in;
		} */

		ol, ul, p, pre {
			font-size: 2.5rem;
			color: #F8F8F2;
			font-family: "Press Start 2P";
			line-height: 1.25;
			letter-spacing: -2px;
		}

		ol, ul, p {
			margin-left: 4rem;
		}

		.slide > p,
		.slide > ul,
		.slide > ol {
			margin-top: 1rem;
		}

		ol ol {
			list-style-type: lower-alpha;
		}

		a {
			color:aqua
		}
	</style>


<style>

.stroke-rain {
	stroke: hsl(0, 100%, 50%);
	animation: strokeHue 2s linear infinite !important;
}

@keyframes strokeHue {
	0%   { stroke: hsl(0,   100%, 50%); }   /* red */
	25%  { stroke: hsl(90,  100%, 50%); }   /* green */
	50%  { stroke: hsl(180, 100%, 50%); }   /* cyan */
	75%  { stroke: hsl(270, 100%, 50%); }   /* purple */
	100% { stroke: hsl(360, 100%, 50%); }   /* back to red */
}

.sub {
	font-size: 60%;
	baseline-shift: -10px;
	/* letter-spacing: -8px; */
}

.super {
	font-size: 60%;
	baseline-shift: 20px;
	/* letter-spacing: -8px; */
}

.sub-space {
	letter-spacing: -11px;
}

.undies {
	font-size: 80%;
}

.ceil {
	baseline-shift: 13px;
}

.hidey-ones {
	opacity: 0;
}

.bullet {
	font-size: 112.5%;
	baseline-shift: 0px;
	letter-spacing: -8px;
}

.bullet-dot {
	font-size: 150%;
	baseline-shift: 6px;
	letter-spacing: -8px;
}

.bullet-dot-rot {
	font-size: 150%;
	baseline-shift: -4px;
    letter-spacing: -21px;
	transform: rotate(45deg)
}

.invis {
	opacity: 0;
}
</style>


	<script>
	    const global_animations = [];
		const global_scrolls = [];
		const state_transitions = new Map();
		const post_processes = [];
		const bullet_post_processes = [];
		const colors2 = new Map([
			["red-orange", "rgb(240, 86, 39)"],
			["blue", "rgb(0, 100, 255)"],
			["yellow", "rgb(255, 255, 102)"],
			["green", "rgb(50, 255, 50)"],
			["cyan", "rgb(0, 255, 255)"],
			["orange", "rgb(255, 177, 100)"],
			["pink", "rgb(255, 112, 255)"],
			["white", "rgb(255, 255, 255)"],
			["dark-green", "rgb(18, 188, 16)"],
			["gold", "rgb(255, 215, 20)"],
			["red", "rgb(255, 99, 132)"],

			//<!-- lime green: rgb(70, 255, 180) -->
		]);
	</script>
</head>

<body style="padding-bottom: 0px; padding-right: 0px">

<svg id="container" viewBox="0 0 1920 1080" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMin meet">
	<g class="slide" id="pre-title"></g>
	<g class="slide" id="title">
		  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7"
            refX="8" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" stroke="rgb(0, 255, 255)"/>
    </marker>

	<marker id="arrowhead-orange" markerWidth="10" markerHeight="7"
            refX="8" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" stroke="rgb(255, 177, 100)"/>
    </marker>
  </defs>
		<text class="h1 title-line" x="965" y="300" fill="#F7A41D" text-anchor="middle">Frequency</text>
		<text class="h1 title-line" x="965" y="500" fill="#F7A41D" text-anchor="middle">Capping</text>

		<g class="title-line">
			<text class="h1" x="965" y="700" fill="#F7A41D" text-anchor="middle">in &nbsp;&nbsp;&nbsp;</text>

			<svg id="zig-logo" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="-1 0 154 140" height="280" width="280" x="965" y="500">
				<g fill="#F7A41D">
					<g id="logo-left-side">
						<polygon points="46,22 28,44 19,30"></polygon>
						<polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"></polygon>
						<polygon points="31,95 12,117 4,106"></polygon>
					</g>
					<g id="logo-middle">
						<polygon points="56,22 62,36 37,44"></polygon>
						<polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"></polygon>
						<polygon points="116,95 97,117 90,104"></polygon>
						<polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"></polygon>
						<polygon points="150,0 52,117 3,140 101,22"></polygon>
					</g>
					<g id="logo-right-side">
						<polygon points="141,22 140,40 122,45"></polygon>
						<polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"></polygon>
						<polygon points="125,95 130,110 106,117"></polygon>
					</g>
				</g>
			</svg>
		</g>

		<text class="h2" id="by-line-1" x="960" y="875" text-anchor="middle">by Niles Salter</text>
		<text class="h3" id="by-line-2" x="960" y="975" text-anchor="middle"><tspan style="stroke: rgb(0, 255, 255);
		stroke-width: 2px">https://validark.dev</tspan></text>

		<script>
			const EXTRA_DELAY = 0.25;

			global_animations.push({
				section: "title",
				selector: ".title-line, #zig-logo",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { "letter-spacing": "-1em", opacity: 0, transform: "scale(0.25) translate(140rem, 50rem)", "font-size": "1rem" },
					30:  { opacity: 1, "font-size": "8rem" },
					100: { "letter-spacing": "-1px", opacity: 1, transform: "scale(1) translate(0, 0)", "font-size": "8rem" },
				}
			}, {
				section: "title",
				selector: ".title-line > text",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "3s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { "letter-spacing": "-1em" },
					100: { "letter-spacing": "-1px" },
				}
			}, {
				section: "title",
				selector: "#by-line-1, #by-line-2",
				slide_num: 0,
				animation_delay: `${2 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { "letter-spacing": "-1em", opacity: 0 },
					25:  { opacity: 1 },
					100: { "letter-spacing": "-7px", opacity: 1 },
				}
			}, {
				section: "title",
				selector: "#logo-left-side",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(75px)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			}, {
				section: "title",
				selector: "#logo-right-side",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(-75px)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			}, {
				section: "title",
				selector: "#logo-middle",
				slide_num: 0,
				animation_delay: `${0 + EXTRA_DELAY}s`,
				animation_duration: "5s",
				ease: "cubic-bezier(0, 1, 0, 1)",
				keyframes: {
					0:   { transform: "scaleX(0) translateX(0)" },
					100: { transform: "scaleX(1) translateX(0)" },
				}
			});
		</script>
	</g>

	<g class="slide" id="intro" title="The problem">
		<g class="bullets" y="175">
Customers can set limits for how often each :cyan:{IPv4 address}@can be shown an :orange:{impression}. E.g.:
 &nbsp;&nbsp;&nbsp;i. &nbsp;&nbsp;1 per minute@&nbsp;&nbsp;ii. &nbsp;10 per hour@&nbsp;iii. 100 per week
Example impression timestamps:
                : :red:{110}&nbsp;&nbsp;:green:{135}&nbsp;&nbsp;:yellow:{140}&nbsp;&nbsp;:pink:{162}&nbsp;&nbsp;:blue:{187}
If we have a limit of :orange:{1 per minute}, we will have spaced these@out more.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 :red:{110}&nbsp;&nbsp;:green:{170}&nbsp;&nbsp;:yellow:{235}&nbsp;&nbsp;:pink:{300}&nbsp;&nbsp;:blue:{372}
This is going to go in our load balancer, therefore we need@high compression and high performance at the same time.
		</g>
	</g>

	<g class="slide" id="solution-1" title="Basic Solution" clicks="13">
		<g id="sol-bullets" class="bullets" y="175">
We can solve this problem by storing :orange:{N} timestamps:
  :When a timestamp goes out of range on the left side, we@can drop it.

		</g>

		<g id="num_slider"></g>

		<script> {
			let i = 0;
			const cs = [...colors2.values()];

			for (const n of [110, 170, 235, 300, 372, 422, 476, 522, 766, 812, 844, 855, 922, 950]) {
				document.getElementById("num_slider").insertAdjacentHTML("afterbegin", `&lt;text id="nummy-${i}" click="4" class="h3" x="${500 + 200 * i}" style="fill:${cs[i % cs.length]}" y="450" text-anchor="middle"&gt;${n}&lt;/text&gt;`);

				if (i > 5) {
					global_animations.push({
						section: "solution-1",
						selector: `#nummy-${i}`,
						slide_num: i - 1,
						animation_delay: `0s`,
						animation_duration: "10s",
						continuous: true,
						ease: "cubic-bezier(0, 1, 0, 1)",
						keyframes: {
							0:   { transform: "translateX(300px)", opacity: 0 },
							100: { transform: "translateX(0px)", opacity: 1 },
						}
					});
				} else {
				}
				global_animations.push({
					section: "solution-1",
					selector: `#nummy-${i}`,
					slide_num: 5 + i,
					animation_delay: `0s`,
					animation_duration: "10s",
					continuous: true,
					ease: "cubic-bezier(0, 1, 0, 1)",
					keyframes: {
						0:   { transform: "translateX(0)", opacity: 1 },
						100: { transform: "translateX(0px)", opacity: 0 },
					}
				});

				global_animations.push({
					section: "solution-1",
					selector: `#num_slider`,
					slide_num: 4 + i,
					animation_delay: `0s`,
					animation_duration: i ? "10s" : "0s",
					ease: "cubic-bezier(0, 1, 0, 1)",
					continuous: true,
					keyframes: {
						0:   { transform: `translateX(${(i-1)*-200}px)` },
						100: { transform: `translateX(${(i)*-200}px)` },
					}
				});

				++i;
			}
			<!-- bullet_post_processes.push(() => {
				const p = document.getElementById("sol-bullets");
				const x = p.children[3];
				let i = 0;
				for (const y of x.children) {
					const id = y.id = "noodley_" + i++;

				}
			}) -->
		}</script>
	</g>

	<g class="slide" id="bucketing" title="Buckets solution" clicks="37">

		<text class="h3" x="160" y="600" text-anchor="start" click="2">timestamp * 15 / 150 % 16</text>

		<g id="num_slider_2"></g>

		<script>{
			const R = 64;
			const D = 120;
			const S = D * 0.7;
			const X = 15;

			document.getElementById("bucketing").insertAdjacentHTML("afterbegin", `&lt;g id="first-boxes" click&gt;${new Array(16).fill().map((_, i) => {
				const box_text = `&lt;text id="box-${i}-0" class="h4" x="${X + 42.5 + D*i}" y="${360}" text-anchor="middle" style="fill: black"&gt;0&lt;/text&gt;`;
				return `&lt;path class="box" fill="${[...colors2.values()][6+Math.floor(i / R)]}" d="M ${X + D * (i % R)} ${300 + (D * Math.floor(i / R))} h ${S} v ${S} h -${S} Z" /&gt;${box_text}&lt;text id="box-label-${i}" class="h4" x="${X + 42.5 + D*i}" y="${295}" text-anchor="middle" style=""&gt;${i}&lt;/text&gt;` +

				new Array(3).fill().map((_, j) => `&lt;g class="range-${j}"&gt;&lt;text class="h4" id="range-${i}-${j}" x="${X + 42.5 + D*i}" y="${415 + j*30}" text-anchor="middle" style="font-size: 16px"&gt;${j*160+i*10}-${j*160+(1+i)*10 - 1}&lt;/text&gt;&lt;/g&gt;`).join('');
			}).join("\n")}&lt;/g&gt;`);

			const slides_to_show_numbers = [3, 24, 24];
			for (let j = 0; j < 3; j++)
				global_animations.push({
					section: "bucketing",
					selector: `.range-${j}`,
					slide_num: slides_to_show_numbers[j],
					animation_delay: `0s`,
					animation_duration: "2s",
					continuous: true,
					keyframes: {
						0:   { transform: "translateY(-30px)", opacity: 0 },
						100: { transform: "translateY(0px)", opacity: 1 },
					}
				});

			let i = 0;
			const cs = [...colors2.values()];
			const num_box_texts = new Array(16).fill(0);
			const num_box_texts2 = new Array(16).fill(0);

			let prev_box_id = 0;

			for (const n of [0, 2, 6, 8, 11, 17, 24, 27, 28, 29, 45, 48, 49, 50, 51, 53, 55, 58, 70, 72, 123, 152, 159, 160, 215, 422, 444, 445, 450, 462, 466, 471, 475, 479]) {
				document.getElementById("num_slider_2").insertAdjacentHTML("afterbegin", `&lt;text id="anummy-${i}" click="3" class="h3" x="${900 + 200 * i}" style="fill:${cs[i % cs.length]}" y="700" text-anchor="middle"&gt;${n}&lt;/text&gt;`);

				const cur_box_id = Math.floor(n / 10);

				if (prev_box_id !== cur_box_id || n === 0) {
					global_animations.push({
						section: "bucketing",
						selector: `#box-label-${prev_box_id % 16}, #range-${prev_box_id % 16}-0, #range-${prev_box_id % 16}-1, #range-${prev_box_id % 16}-2`,
						slide_num: 3 + i,
						animation_delay: `0s`,
						animation_duration: "2s",
						continuous: true,
						skip_auto_prev_state: true,
						ease: "cubic-bezier(0, 1, 0, 1)",
						keyframes: {
							0:   { fill: "cyan" },
							100: { fill: "hsl(265, 89%, 78%)" },
						}
					});

					global_animations.push({
						section: "bucketing",
						selector: `#box-label-${cur_box_id % 16}, #range-${cur_box_id % 16}-0, #range-${cur_box_id % 16}-1, #range-${cur_box_id % 16}-2`,
						slide_num: 3 + i,
						animation_delay: `0s`,
						animation_duration: "2s",
						continuous: true,
						skip_auto_prev_state: true,
						ease: "cubic-bezier(0, 1, 0, 1)",
						keyframes: {
							0:   { fill: "hsl(265, 89%, 78%)" },
							100: { fill: "cyan" },
						}
					});
				}

				for (let box_id_ = (prev_box_id + (prev_box_id !== cur_box_id)); box_id_ <= cur_box_id; ++box_id_) {
					const box_id = box_id_ % 16;
					let prev_box_text = num_box_texts2[box_id];
					num_box_texts2[box_id] = box_id_ === cur_box_id ? 1 + (prev_box_id === cur_box_id ? num_box_texts2[box_id] : 0) : 0;
					if (num_box_texts2[box_id] === 0 && prev_box_text === 0 && n < 215) continue;

					global_animations.push({
						section: "bucketing",
						selector: `#box-${box_id}-${num_box_texts[box_id]}`,
						slide_num: 3 + i,
						animation_delay: `0s`,
						animation_duration: "10s",
						continuous: true,
						ease: "cubic-bezier(0, 1, 0, 1)",
						keyframes: {
							0:   { transform: "translateY(0px)", opacity: 1 },
							100: { transform: "translateY(-50px)", opacity: 0 },
						}
					});

					document.getElementById(`box-${box_id}-${num_box_texts[box_id]}`).insertAdjacentHTML("afterend", `&lt;text id="box-${box_id}-${++num_box_texts[box_id]}" click="${3 + i}" class="h4" x="${X + 42.5 + D*box_id}" y="${360}" text-anchor="middle" style="fill: black"&gt;${num_box_texts2[box_id]}&lt;/text&gt;`);

					global_animations.push({
						section: "bucketing",
						selector: `#box-${box_id}-${num_box_texts[box_id]}`,
						slide_num: 3 + i,
						animation_delay: `0s`,
						animation_duration: "4s",
						continuous: true,
						ease: "cubic-bezier(0, 1, 0, 1)",
						keyframes: {
							0:   { transform: "translateY(50px)", opacity: 0, fill: "red" },
							100: { transform: "translateY(0px)", opacity: 1, fill: "black" },
						}
					});
				}
				console.log('done');
				prev_box_id = cur_box_id;


				global_animations.push({
					section: "bucketing",
					selector: `#anummy-${i}`,
					slide_num: 3 + i,
					animation_delay: `0s`,
					animation_duration: "4s",
					continuous: true,
					ease: "cubic-bezier(0, 1, 0, 1)",
					keyframes: {
						0:   { transform: "translateX(100px)", opacity: 0 },
						100: { transform: "translateX(0px)", opacity: 1 },
					}
				});

				global_animations.push({
					section: "bucketing",
					selector: `#anummy-${i}`,
					slide_num: 4 + i,
					animation_delay: `0s`,
					animation_duration: "10s",
					continuous: true,
					ease: "cubic-bezier(0, 1, 0, 1)",
					keyframes: {
						0:   { transform: "translateX(0)", opacity: 1 },
						100: { transform: "translateX(0px)", opacity: 0 },
					}
				});

				global_animations.push({
					section: "bucketing",
					selector: `#num_slider_2`,
					slide_num: 3 + i,
					animation_delay: `0s`,
					animation_duration: i ? "4s" : "0s",
					ease: "cubic-bezier(0, 1, 0, 1)",
					continuous: true,
					keyframes: {
						0:   { transform: `translateX(${(i-1)*-200}px)` },
						100: { transform: `translateX(${(i)*-200}px)` },
					}
				});

				++i;
			}

		}</script>
	</g>

	<g class="slide" id="division-1" title="Division Digression I">
		<text class="h3" x="160" y="600" text-anchor="start">timestamp * 15 / 150 % 16</text>
		<text class="h4" x="160" y="640" text-anchor="start" click="1">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</text>
		<text class="h4" x="750" y="680" text-anchor="start" click="1">How do we perform this calculation??</text>

		<text class="h4" x="160" y="750" text-anchor="start" click="2">(((timestamp << 4) - timestamp) / 150) & 15</text>
	</g>

	<g class="slide" id="division-2" title="Division Digression II">
		<g class="code" x="-75" y="150" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig" hide-line-numbers>
const V = @Vector(8, u64);

export fn foo(a: V, b: V) V {
    return a / b;
}
		</g>

	<g click class="code" x="750" y="150" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background hide-line-numbers lang="asm">
foo:
	vextracti32x4   xmm2, zmm0, 3
	vextracti32x4   xmm3, zmm1, 3
	xor     edx, edx
	vextracti32x4   xmm5, zmm1, 2
	vpextrq rax, xmm2, 1
	vpextrq rcx, xmm3, 1
	vmovq   rsi, xmm5
	div     rcx
	vmovq   rcx, xmm3
	vextracti32x4   xmm3, zmm0, 2
	xor     edx, edx
	vmovq   xmm4, rax
	vmovq   rax, xmm2
	div     rcx
	vpextrq rcx, xmm5, 1
	xor     edx, edx
	vmovq   xmm2, rax
	vpextrq rax, xmm3, 1
	div     rcx
	vpunpcklqdq     xmm2, xmm2, xmm4
	xor     edx, edx
	mov     rcx, rax
	vmovq   rax, xmm3
	vmovq   xmm3, rcx
	div     rsi
	xor     edx, edx
	vmovq   xmm4, rax
	vpunpcklqdq     xmm3, xmm4, xmm3
	vextracti128    xmm4, ymm1, 1
	vinserti128     ymm2, ymm3, xmm2, 1
	vextracti128    xmm3, ymm0, 1
	vpextrq rcx, xmm4, 1
	vpextrq rax, xmm3, 1
	div     rcx
	vmovq   rcx, xmm4
	xor     edx, edx
	vmovq   xmm5, rax
	vmovq   rax, xmm3
	div     rcx
	vpextrq rcx, xmm1, 1
	xor     edx, edx
	vmovq   xmm3, rax
	vpextrq rax, xmm0, 1
	div     rcx
	vmovq   rcx, xmm1
	vpunpcklqdq     xmm3, xmm3, xmm5
	xor     edx, edx
	vmovq   xmm4, rax
	vmovq   rax, xmm0
	div     rcx
	vmovq   xmm0, rax
	vpunpcklqdq     xmm0, xmm0, xmm4
	vinserti128     ymm0, ymm0, xmm3, 1
	vinserti64x4    zmm0, zmm0, ymm2, 1
	ret
		</g>
	</g>

	<g class="slide" id="division-3" title="Division Digression III">
		<g class="code" x="-75" y="150" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig" hide-line-numbers>
const V = @Vector(8, u32);

export fn foo(timestamp: u32) V {
    return @as(V, @splat(timestamp)) /
		@as(V, .{
			300,
			86400,
			7*86400,
			30*86400,
			60*86400,
			90*86400,
			180*86400,
			365*86400
		});
}
		</g>
<g class="code" x="-75" y="1400" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background hide-line-numbers lang="asm">
.LCPI0_0:
	.long   3257812231
	.zero   4
	.long   3474999713
	.zero   4
	.long   2316666475
	.zero   4
	.long   1142465659
	.zero   4
.LCPI0_1:
	.long   458129845
	.long   3257812231
	.long   1861606989
	.long   3474999713
	.long   3474999713
	.long   2316666475
	.long   2316666475
	.long   1142465659
.LCPI0_3:
	.long   5
	.long   16
	.long   18
	.long   21
	.long   22
	.long   22
	.long   23
	.long   23
.LCPI0_4:
	.byte   1
	.byte   9
	.byte   3
	.byte   11
	.byte   5
	.byte   13
	.byte   7
	.byte   15
foo:
	vpbroadcastd    ymm0, edi
	vpmuludq        ymm1, ymm0, ymmword ptr [rip + .LCPI0_0]
	vpmuludq        ymm0, ymm0, ymmword ptr [rip + .LCPI0_1]
	vpmovsxbd       ymm2, qword ptr [rip + .LCPI0_4]
	vpermi2d        ymm2, ymm0, ymm1
	vpsrlvd ymm0, ymm2, ymmword ptr [rip + .LCPI0_3]
	ret
</g>
	</g>

	<g class="slide" id="division-4" title="Division Digression IV">
		<g class="bullets" y="175">
:We can do the calculations the compiler does when we are@given an update to our time limit!
  :See :yellow:{Integer Division by Constants: Optimal Bounds} by@Daniel Lemire, Colin Bartlett, & Owen Kaser
:For our use case, we can do something even more efficient@and simpler!
  ::pink:{t / D} is the same as :pink:{t * (1 / D)}
  ::cyan:{t / D} is the same as :cyan:{(t * (2^{52} / D)) / 2^{52}}@&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:orange:{^^^^^^ +1 for integers}
    :Warning this technique is not sufficient precision for@all use cases. :orange:{Kids, don't try this at home!}
:We have :cyan:{vpmadd52huq} which computes a 52-bit multiply,@then takes the upper 52 bits of the 104 bit result.
  :We can use this to do 8 divisions per instruction, with@a 4 cycle latency and a throughput of 2 per cycle on@newer CPUs! In practice, we use 2 :cyan:{vpmadd52huq}'s to do@```16 divisions in 4 cycles!```
		</g>
	</g>

	<g class="slide" id="bit-manip">
		<g class="code" x="-75" y="20" width="1920" line-height="80" line-num-indent="80" line-indent="100" hide-background lang="zig" hide-line-numbers steps="1,2,3,4,5,6,9,8:4,8:4,8:4,8:4">
		const V = @Vector(8, u64);
		const cur_block: V = timestamp.divide(durations);
        const prev_block: V = self.prev_timestamp.divide(durations);
        const block_skip = cur_block - prev_block;
		const incr_masks: @Vector(64, u8) = @bitCast(
			simd.rotl(@as(V, @splat(1)), cur_block)
		);
		const delete_masks: @Vector(64, u8) = @bitCast(simd.rotl(
			simd.vpsllv(@as(V, @splat(std.math.maxInt(denom_int))), block_skip),
			-%~prev_block,
		));
		</g>
		<text class="h3" x="460" y="1025" text-anchor="start" click="7">&nbsp;1111111111111111 << 4</text>
		<text class="h3" x="460" y="1100" text-anchor="start" click="8-9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1111111111110000</text>
		<text class="h3" x="460" y="1100" text-anchor="start" click="9">rotl(1111111111110000, 5)</text>
		<text class="h3" x="460" y="1175" text-anchor="start" click="10">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1111111000011111</text>
	</g>

	<g class="slide" id="interleaving" title="Doing it with SIMD">
		<script>{
			const R = 64;
			const D = 29;
			const S = D * 16 / 18;

			const X = 30;

			document.getElementById("interleaving").insertAdjacentHTML("afterbegin", `&lt;g id="non-interleaved-boxes" click&gt;${new Array(8*64).fill().map((_, i) => {
				return `&lt;path class="box" fill="${[...colors2.values()][Math.floor(i / R)]}" d="M ${X + D * (i % R)} ${300 + (D * Math.floor(i / R))} h ${S} v ${S} h -${S} Z" /&gt;`;
			}).join("\n")}&lt;/g&gt;`);

			document.getElementById("non-interleaved-boxes").insertAdjacentHTML("afterbegin", `&lt;g click&gt;${new Array(8*64).fill().map((_, i) => {
				return `&lt;path class="box" fill="${[...colors2.values()][Math.floor(i / 8 % 8)]}" d="M ${X + D * (i % R)} ${600 + (D * Math.floor(i / R))} h ${S} v ${S} h -${S} Z" /&gt;`;
			}).join("\n")}&lt;/g&gt;`);
		}</script>
	</g>

	<g class="slide" id="future" title="Future work">
		<g class="bullets" y="175">
:We plan on being ready to ship next week!!
		</g>
	</g>

	<g class="slide" id="end">
		<text class="h2" x="960" y="525" text-anchor="middle" style="font-size: 100px; letter-spacing:0.1px;">fin</text>


<script>
{
	const bullets = {
		0: "&lt;tspan class=\"bullet\"&gt;&bullet;&lt;/tspan&gt;&ThinSpace;&ThinSpace;&ThinSpace;&ThinSpace;",
		2: "&lt;tspan class=\"bullet-dot\"&gt;.&lt;/tspan&gt;&ThinSpace;",
		4: "&ThinSpace;&ThinSpace;&lt;tspan rotate=\"-45\" class=\"bullet-dot-rot\"&gt;.&lt;/tspan&gt;&ThinSpace;",
	};

	const semicolons = {
		0: "&lt;tspan class=\"invis bullet\"&gt;&bullet;&lt;/tspan&gt;&ThinSpace;&ThinSpace;&ThinSpace;&ThinSpace;",
		2: "&lt;tspan class=\"invis bullet-dot\"&gt;.&lt;/tspan&gt;&ThinSpace;",
		4: "&ThinSpace;&ThinSpace;&lt;tspan rotate=\"-45\" class=\"invis bullet-dot-rot\"&gt;.&lt;/tspan&gt;&ThinSpace;",
	};

	for (const bulleted of document.getElementsByClassName("bullets")) {
		let click_offset = 1;
		let iter = 0;
		let iter2 = 0;
		let y = +bulleted.getAttribute('y') - 70;
		let tmp = 0;


		let lines = bulleted.innerHTML
			.split('\n')
			.filter(e => e.trimRight())
			.flatMap(e => {
				const sub_lines = e.split('@');
				const first_line_prefix = sub_lines[0].match(/^ */)[0];
				for (let i = 0; ++i < sub_lines.length;)
					sub_lines[i] = first_line_prefix + '@' + sub_lines[i];
				sub_lines[0] = "$$$" + sub_lines[0];
				return sub_lines;
			});

		const unnecessary_whitespace = lines
			.reduce((a, c) => Math.min(a, c.length - c.trimRight().length), Number.POSITIVE_INFINITY);

		function boop(x,y) {
			return colors2.get(x);
		}


		let indentation;
		let using_semis;

		const my_lines = lines.map((x, i) => {
			indentation = x.match(/^\$\$\$/) ? x.match(/^( *)/)?.[1]?.length : indentation;
			using_semis = x.match(/^\$\$\$/) ? x.match(/^\$\$\$( *):/) : using_semis;

			const is_cont = !x.match(/^\$\$\$/);
			const use_semis = is_cont && using_semis;
			x = x.replace(/^\$\$\$/, "");
			x = x.slice(unnecessary_whitespace);
			x = x.replaceAll(/^~/g, (_, spaces) => (click_offset++, ""));
			x = x.replace(/^( *):/, (_, spaces) => "&nbsp;".repeat(spaces.length) + (bullets[spaces.length] ?? ""));
			x = x.replace(/^( *)@/, (_, spaces) => "&nbsp;".repeat(spaces.length) + ((use_semis ? semicolons : {})[indentation] ?? ""));
			x = x.replace(/^( *)/, (_, spaces) => "&nbsp;".repeat(spaces.length));
			x = x.replaceAll(/([^\\]):([)OopPD(])(?!\w)/g, (_, char, content) => char + `&lt;tspan style="letter-spacing: -32px" rotate="90" fill=\"${'cyan'}\"&gt;&lt;tspan style="baseline-shift: 42px;"&gt;:&lt;/tspan&gt;&lt;tspan style="baseline-shift: 22px;"&gt;${content}&lt;/tspan&gt;&lt;/tspan&gt;`);
			x = x.replaceAll(/\_\{(.+?)\}/g, (_, content) => `&lt;tspan class=\"sub\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/\^\{(.+?)\}/g, (_, content) => `&lt;tspan class=\"super\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/([^\\]):(.+?):{(.+?)\}/g, (_, char, color, content) => char + `&lt;tspan fill=\"${boop(color, content)}\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/```(.+?)```/g, (_, content) => `&lt;tspan class=\"stroke-rain\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/``(.+?)``/g, (_, content) => `&lt;tspan class=\"highlighted\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll(/`(.+?)`/g, (_, content) => `&lt;tspan class=\"highlighted-blue\"&gt;${content}&lt;/tspan&gt;`);
			x = x.replaceAll("naive", "naïve");
			x = x.replaceAll("\\:", ":");

			return `&lt;text click="${i + click_offset}" class="h4" x="30" y="${y += 45 + (is_cont ? 0 : 35) }" text-anchor="start"&gt;${x}&lt;/text&gt;`
		}).join("");
		bulleted.innerHTML = my_lines;
	}

	for (const codeblock of document.getElementsByClassName("code")) {
		const steps = codeblock.getAttribute("steps") || codeblock.getAttribute("mini-steps");
		if (steps) {
			let slide = codeblock;
			do slide = slide.parentNode; while (!slide.classList.contains("slide"));
			slide.setAttribute('clicks', steps.split(',').length + 1);
		}
	}

	for (const slide of document.getElementsByClassName("slide")) {
		const title = slide.getAttribute('title')
		if (title) {
			slide.insertAdjacentHTML("afterbegin", `&lt;text class="h2" x="980" y="100" text-anchor="middle"&gt;${title}&lt;/text&gt;`);
		}
	}

	for (const bullet_post_process of bullet_post_processes) {
		bullet_post_process();
	}

}
</script>
	</g>
</svg>

<svg id="overlay" style="overflow: hidden; width: 100%;" y="5000" viewBox="0 0 1920 1080" version="1.1" xmlns="http://www.w3.org/2000/svg">
</svg>

<style>
	#button-left, #button-right {
		position: fixed;
		font-size: 2rem;
		font-family: 'Press Start 2P';
		bottom: 1rem;
		color: white;
		text-align: center;
		align-content: center;
		height: 1.5rem;
		width: 4rem;
		padding: 0.5rem 0.85rem;
		background: none;
		border: none;
	}

	#button-left {
		left: 0rem;
	}

	#button-right {
		right: 0rem;
	}

	.code-star {
		alignment-baseline: middle;
	}

	.code-color-white { fill: #fff; }
	.code-color-0 { fill: rgb(80, 250, 123); }
	.code-color-1 { fill: #60f4d4; }
	.code-color-2 { fill: rgb(189, 147, 249); }
	.code-color-3 { fill: rgb(255, 121, 198); }
	.code-color-4 { fill: rgb(255, 184, 104); }
	.code-color-5 { fill: #F1FA8C; }
	.code-color-6 { fill: #7960f4; }
	.code-color-7 { fill: #f46060; }
	/* .code-color-8 { fill: #60f4d4; } */

	.code-block-label {
		text-decoration: underline;
		fill: rgb(80, 250, 123);
	}

	.code-builtin {
		fill: rgb(139, 233, 253);
	}

	.code-num {
		fill: rgb(189, 147, 249);
	}

	.code-type, .code-keyword, .code-symbol-1, .code-symbol-2 {
		fill: rgb(255, 121, 198);
	}

	.code-symbol-2 {
		baseline-shift: -14px;
	}

	.code-struct-type {
		fill: rgb(255, 184, 104);
		font-style: italic;
	}

	.code-register {
		fill: #b6c8ff;
	}

	.code-register-2, .code-register-3 {
		fill: rgb(255, 184, 104);
		font-style: italic;
	}

	.code-comment {
		font-style: normal;
		fill: #6272a4;
	}

	.code-type {
		font-style: italic;
	}

	.code-string {
		fill: #F1FA8C;
	}

	.code-space {
		fill: rgb(98, 114, 164);
	}

	.bit-1 {
		fill: #F1FA8C;
	}

	.line-of-code, .line-number, .bits, .label, .small-label, .xsmall-label, .ysmall-label, .big-label {
		font-family: 'Iosevka', 'Press Start 2P', 'Courier New', Courier, monospace;
		font-size: 64px;
		letter-spacing: -6px;
		fill: rgb(248, 248, 242)
	}

	.bits, .bits .code-type {
		font-style: normal;
	}

	.line-number {
		font-size: 45px;
	}

	.label {
		font-size: 40px;
		baseline-shift: 10px;
		letter-spacing: -4px;
	}

	.small-label {
		font-size: 28px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.xsmall-label {
		font-size: 20px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.ysmall-label {
		font-size: 25px;
		baseline-shift: 10px;
		letter-spacing: -1px;
	}

	.big-label {
		font-size: 70px;
	}

	.code-func-name {
		fill: rgb(80, 250, 123);
	}

	.code-instruction {
		fill: rgb(255, 121, 198);
	}

	.code-keyword-asm {
		fill: rgb(255, 184, 104);
	}

	.code-curly-0 { fill: rgb(248, 248, 242); }
	.code-curly-1 { fill: rgb(255, 121, 198); }
	.code-curly-2 { fill: rgb(139, 233, 253); }
	.code-curly-3 { fill: rgb(80, 250, 123); }
	.code-curly-4 { fill: rgb(189, 147, 249); }
	.code-curly-5 { fill: rgb(255, 184, 104); }

	.code-paren-0 { fill: rgb(248, 248, 242); }
	.code-paren-1 { fill: #F1FA8C; }
	.code-paren-2 { fill: rgb(255, 184, 104); }
	.code-paren-3 { fill: rgb(255, 121, 198); }
 	.code-paren-4 { fill: rgb(189, 147, 249); }
 	.code-paren-5 { fill: rgb(139, 233, 253); }

	.code-brack-0 { fill: #F1FA8C; }
	.code-brack-1 { fill: rgb(255, 184, 104); }
	.code-brack-2 { fill: rgb(255, 121, 198); }
	.code-brack-3 { fill: rgb(189, 147, 249); }
	.code-brack-4 { fill: rgb(139, 233, 253); }
	.code-brack-5 { fill: rgb(248, 248, 242); }

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Bold-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Bold-Italic.woff') format('woff');
		font-weight: 700;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Bold.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Bold.woff') format('woff');
		font-weight: 700;
		font-style: normal;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold-Italic.woff') format('woff');
		font-weight: 800;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-ExtraBold.woff') format('woff');
		font-weight: 800;
		font-style: normal;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Italic.woff') format('woff');
		font-weight: 400;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Medium-Italic.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Medium-Italic.woff') format('woff');
		font-weight: 500;
		font-style: italic;
		font-display: swap;
	}

	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Medium.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Medium.woff') format('woff');
		font-weight: 500;
		font-style: normal;
		font-display: swap;
	}
	@font-face {
		font-family: 'JetBrains Mono';
		src: url('./fonts/JetBrainsMono/JetBrainsMono-Regular.woff2') format('woff2'),
			url('./fonts/JetBrainsMono/JetBrainsMono-Regular.woff') format('woff');
		font-weight: 400;
		font-style: normal;
		font-display: swap;
	}
</style>

<button id="button-left" onclick="goBackward()">&lt;</button>
<button id="button-right" onclick="goForward()">&gt;</button>

<style>
	.thin-space {
		letter-spacing: -0.3em;
	}
</style>


<script>
	const code_snippets = new Map();
	code_snippets.set("title", "Frequency Capping\nby Niles Salter (validark.dev)");

	function processRanges(ranges, joined_lines) {
		return ranges
			.reduce((a, [n, start, end]) =>
				`${a.slice(0, start)}<tspan class="code-${n}">${n === "register-2" ? "<tspan class=\"thin-space\">&nbsp;</tspan>" : ""}${
					a.slice(start, end)
					.replaceAll(/ +/g, e => "&nbsp;".repeat(e.length))
				}${n === "register-2" ? "<tspan class=\"thin-space\">&nbsp;</tspan>" : ""}</tspan>${a.slice(end)}`,
				joined_lines.replaceAll("&gt;", ">").replaceAll("&lt;", "<")
			)
			.split('\n');
	}

	function preprocess(slide_id, text, lang) {
		let start_pos = text.indexOf("\n");
		let end_pos = text.lastIndexOf("\n");

		if (text.slice(0, start_pos + 1).trim() !== "")
			start_pos = -1;

		if (text.slice(end_pos, -1).trim() !== "")
			end_pos = -1

		let lines = text
			.slice(start_pos + 1, end_pos)
			.split('\n')
			.map(e => e.trimRight().replaceAll('\t', '    '));

		const unnecessary_whitespace = lines
			.filter(e => e)
			.reduce((a, c) => Math.min(a, c.length - c.trimLeft().length), Number.POSITIVE_INFINITY);

		lines = lines.map(e => e.slice(unnecessary_whitespace));
		code_snippets.set(slide_id, (code_snippets.get(slide_id) || "") +
			lines
				.join("\n")
				.replaceAll("&gt;", ">")
				.replaceAll("&lt;", "<")
				.replaceAll("&amp;", "&")
		);
		let curly_depth = 0;
		let paren_depth = 0;

		const joined_lines = lines.join('\n')
			.replaceAll("&gt;&gt;", "&raquo;")
			.replaceAll("&lt;&lt;", "&laquo;")
			.replaceAll("-&gt;", "&RightArrow;")
			.replaceAll(" =&gt; ", " &rArr; ")
			.replaceAll(" != ", " &ne; ")
			.replaceAll(" &lt;= ", " &le; ")
			.replaceAll(" &gt;= ", " &ge; ")
			// .replaceAll(" == ", " &Equal; ")
			.replaceAll("&lt;", "<")
			.replaceAll("&gt;", ">");

		const ranges = new Array();

		// for (; )
		// for (let regex = /".+?"/g, cur = regex.exec(joined_lines); cur; cur = regex.exec(joined_lines));

		// const meme = RegExp.prototype.exec.bind(/".+?"/g, joined_lines);
		// joined_lines;

		const in_match = new Array(joined_lines.length).fill(false);

		if (lang === 'zig' || lang === 'ziggy') {
			// console.log(joined_lines);

			// let pos = 0;
			for (const match of joined_lines.matchAll(lang === "ziggy"
			? /\/\/([^_]*|$)|"[^_]*?(?<!\\)"|'[^_]*?'|\\\\([^_]*|$)/g
			: /\/\/([^\n]*|$)|"[^\n]*?(?<!\\)"|'[^\n]*?'|\\\\([^\n]*|$)/g)) {
				const { index, 0: { length } } = match;
				for (let q = 0; q < length; q++) in_match[index + q] = true;
				ranges.push([match[0][0] === '/' ? "comment" : "string", index, index + length]);
			}



			// for (const [regex, name] of [
			// 	[/\/\/([^\n]*|$)/g, "comment"],
			// 	[/"[^\n]*?"|'[^\n]*?'/g, "string"],
			// ]) {
			// 	outer: for (const { index, 0: s } of joined_lines.matchAll(regex)) {
			// 		const { length } = s;
			// 		// console.log({index, length, s})
			// 		for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
			// 		for (let q = 0; q < length; q++) in_match[index + q] = true;
			// 		ranges.push([name, index, index + length]);
			// 	}
			// }

			for (const [regex, name] of [
				[/(?<!\w)(usingnamespace|linksection|threadlocal|unreachable|addrspace|allowzero|nosuspend|anyframe|callconv|comptime|continue|errdefer|noinline|volatile|anytype|noalias|suspend|export|undefined|extern|inline|opaque|orelse|packed|false|true|null|resume|return|struct|switch|align|async|await|break|catch|const|defer|error|union|while|else|enum|test|and|asm|for|pub|try|var|fn|if|or)(?!\w)/g, "keyword"],
				[/(?<!\w)(Carry|HHID|Foo|Bar|Allocator|IndexItem|FastDivider32|IpAddress|V|T)(?!\w+)/g, "struct-type"],
				[/@\w+/g, "builtin"],
				[/ +/g, "space"],
				[/(?:&rArr;)|(?:&amp;)|(?:&ne;)|(?:&le;)|(?:&ge;)|(?:&Equal;)|(?:&raquo;)|(?:&laquo;)|(?:&RightArrow;)|[+*-]?%|\.\.\.?|[:=><!+~?|^/-]|\.(?=\*)|(?<!\.)\*/ug, "symbol-1"],
				[/(?<=\.)\*/g, "symbol-2"],
				[/\w+(?=\()|(?<=fn )\w+/g, "func-name"],
				[/(?<!\w)(?:[ui]\d+|void|bool|u?int|[ui]size)(?!\w)/g, "type"],
				[/(?<!\w)0x[\dA-Fa-f]+/g, "num"],
				[/(?<!\w)(?:0[b])?\d+/g, "num"],
				[/\*/g, "star"],
			]) {
				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}
		} else if (lang === "asm") {
			for (const [regex, name] of [
				[/"[^\n]+?"|'[^\n]+?'/g, "string"],
				[/;([^\n]+|$)/g, "comment"],
			]) {
				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}

			for (const [regex, name] of [
				[/ +/g, "space"],
				[/\+/g, "symbol-1"],
				[/\*/g, "star"],
				[/(?<!\w)(?:[re]?[abcd]x|[abcd][hl]|[er]?[sb]p|[er]?[ds]i|r[89][bwd]?|r1[0-5][bwd]?|[xyz]mm[0-9]|zmm[12][0-9]|[xy]mm1[0-5]|zmm3[01]|rip)(?!\w)/g, "register"],
				[/(?<=\{)(?:k[0-7])(?=\})/g, "register-2"],
				[/(?<!\w)(?:k[0-7])(?!\w)/g, "register-3"],
				// [/[:=]/g, "symbol-1"],
				[/.LBB\d+_\d+/g, "block-label"],
				[/(?<!\w)0x\d+/g, "num"],
				[/(?<!\w)-?\d+/g, "num"],
				[/(?<=call +)[_.\w]+/g, "func-name"],
				[/(?<=\+ ?)[_.\w]+/g, "func-name"],
				[/(?<=^|\n)[_.\w]+:/g, "func-name"],
				[/(?<!\w)(qword|ptr|dword|byte|word|xmmword|ymmword|zmmword)(?!\w)/g, "keyword-asm"],
				[/(?<=^[ \t]*|\n[ \t]*)\.?\w+/g, "instruction"],
				]) {
					if (name === "instruction") {
						for (const x of joined_lines.matchAll(regex)) {
							const { index, 0: { length } } = x;
							// console.log(index, length, x);
						}
					}

				outer: for (const { index, 0: { length } } of joined_lines.matchAll(regex)) {
					if (length === 0) throw new Error("bad news");
					for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
					for (let q = 0; q < length; q++) in_match[index + q] = true;
					ranges.push([name, index, index + length]);
				}
			}
		} if (lang === "rainbow") {
			let cur_color = 0;
			for (let i = 0; i < joined_lines.length; ) {
				for (; i < joined_lines.length && joined_lines[i] !== '1'; i++) {
					ranges.push([`color-white`, i, i + 1]);
				}
				for (; i < joined_lines.length && joined_lines[i] === '1'; i++) {
					ranges.push([`color-${5}`, i, i + 1]);
				}
				cur_color += 1;
			}
		}


		// .replaceAll(//g, (_, pre, e) => `${pre}<tspan class="code-func-name">${e}</tspan>`)

		for (const [regex, name, [opener, closer]] of [
			[/[{}]/g, "curly", "{}"],
			[/[()]/g, "paren", "()"],
			[/[[\]]/g, "brack", "()"],
		]) {
			outer: for (const { index, 0: { 0: e, length } } of joined_lines.matchAll(regex)) {
				for (let q = 0; q < length; q++) if (in_match[index + q]) continue outer;
				for (let q = 0; q < length; q++) in_match[index + q] = true;
				if (e === closer) {
					curly_depth--;
				}

				ranges.push([`${name}-${curly_depth % 6}`, index, index + length]);

				if (e === opener) {
					curly_depth++;
				}
			}
		}

		return [
			processRanges(ranges.sort(([, a], [, b]) => b - a), joined_lines),
			ranges
		];
	}

	const container = document.getElementById("container");
	const overlay = document.getElementById("overlay");
	const slide_elements = [...container.children];
	const overlay_elements = slide_elements.map(e => document.getElementById(e.id + "-overlay") || (() => {
		// console.log(e);
		overlay.insertAdjacentHTML("beforeend", `<g class="slide" id="${e.id}-overlay"></g>`)
		return document.getElementById(`${e.id}-overlay`);
	})());

	const EmptyFunction = () => {};

	const clicks = new Map();
	const slidesById = new Map();
	const pane_heights = new Map();

function applyState(line, s) {
  line.setAttribute("x1", s.x1);
  line.setAttribute("y1", s.y1);
  line.setAttribute("x2", s.x2);
  line.setAttribute("y2", s.y2);
}

let my_thread = { id: 0 };

// Critically damped (no overshoot, fastest)
const STIFFNESS_DEFAULT = 25;
const zeta = 1; // critical
const DAMPING_DEFAULT = 2 * Math.sqrt(STIFFNESS_DEFAULT) * zeta; // ≈ 10

// Slightly overdamped (no overshoot, a bit “heavier” feel)
// const stiffness = 25;
// const zeta = 1.2;
// const damping = 2 * Math.sqrt(stiffness) * zeta; // ≈ 12


// const STIFFNESS_DEFAULT = 0.6;
// const DAMPING_DEFAULT = 1;



function springTween(line, from, to, opts = {}) {
  let state = { ...from };
  let velocity = { x1: 0, y1: 0, x2: 0, y2: 0 };

  const stiffness = opts.stiffness ?? STIFFNESS_DEFAULT;   // spring strength (per second)
  const damping   = opts.damping   ?? DAMPING_DEFAULT;    // damping (per second)

  const my_thread_id = my_thread.id;
  let lastTime = null;

  function animate(timestamp) {
    if (lastTime === null) lastTime = timestamp;

    const deltaMs = timestamp - lastTime;
    const dt = deltaMs / 500;       // convert to seconds
    lastTime = timestamp;

    let done = true;

    if (my_thread_id === my_thread.id) {
      for (let key in state) {

        // displacement
        const dist = to[key] - state[key];

        // spring force (Hooke's law) scaled by dt
        const springForce = dist * stiffness;

        // damping force scaled by velocity
        const dampingForce = velocity[key] * damping;

        // acceleration
        const accel = springForce - dampingForce;

        // integrate velocity & position
        velocity[key] += accel * dt;
        state[key] += velocity[key] * dt;

        // check if still moving noticeably
        if (Math.abs(dist) > 0.1 || Math.abs(velocity[key]) > 0.01) {
          done = false;
        }
      }
    }

    if (done) {
      applyState(line, to);
    } else {
      applyState(line, state);
      requestAnimationFrame(animate);
    }
  }

  requestAnimationFrame(animate);
}




// <!-- [553, 631], [820, 787], [957, 958], [1157.25, 1129], [1224, 1278] -->
const startState = { x1: 553, y1: 250, x2: 631, y2: 429 };
const endState   = { x1: 820, y1: 250, x2: 787, y2: 429 };

	function recursivelyHandleChildren(child_state_transitions, child, current_click_num) {
		for (const grandchild of child.children) {
			let click_attr = grandchild.getAttribute("click")
			if (click_attr !== null) {
				grandchild.setAttribute("hidden", "");
				const [click, click2] = click_attr.split('-');
				const clicky = (click === "") ? ++current_click_num : parseInt(click) || 1;

				// if (grandchild.id === "change-highlighted-color") {
				// 	console.log({grandchild})
				// }

				if (grandchild.tagName === "line" && clicky && click && click2) {
					//console.log({clicky, click, click2})
					const data1 = [+grandchild.getAttribute("x1"),
										+grandchild.getAttribute("x2"),
										+grandchild.getAttribute("y1"),
										+grandchild.getAttribute("y2"),];

					data1.stiffness = STIFFNESS_DEFAULT;
					data1.damping = DAMPING_DEFAULT;

					const map = new Map([
						[click - 1, data1]
					]);

					for (let i = +click; i <= +click2; i++) {
						const data = grandchild.getAttribute(`click-${i}`)?.split(', ');
						map.set(i, data);
					}

					//console.log({map});
					const thread_incrementers = new Set();

					for (const [i, data] of map.entries()) {
						if (data) {
							const damping = data.damping ?? grandchild.getAttribute("damping") ?? DAMPING_DEFAULT;
							const stiffness = data.stiffness ?? grandchild.getAttribute("stiffness") ?? STIFFNESS_DEFAULT;
							const [x1, x2, y1=250, y2=429-50] = data;
							// console.log({x1, x2,y1,y2});
							thread_incrementers.add(i);

							child_state_transitions[i]?.push(() => {
								springTween(grandchild,
									{
										x1: +grandchild.getAttribute("x1"),
										y1: +grandchild.getAttribute("y1"),
										x2: +grandchild.getAttribute("x2"),
										y2: +grandchild.getAttribute("y2"),
									},
									{
										x1: +x1,
										y1: +y1,
										x2: +x2,
										y2: +y2,
									},
									{ stiffness, damping });
							});
						}
					}

					for (const i of thread_incrementers)
						child_state_transitions[i]?.unshift(() => my_thread.id++)
				}

				const unhide_slide = () => {
					// setTimeout(() => grandchild.removeAttribute("hidden"), 1000);
					grandchild.classList.remove("hide-slide");
					grandchild.classList.add("unhide-slide");
					grandchild.removeAttribute("hidden");
				};


				const hide_slide = () => {
					// console.log("hiding", grandchild);
					grandchild.classList.remove("unhide-slide");
					grandchild.classList.add("hide-slide");
					grandchild.setAttribute("hidden", "");


					// setTimeout(() => {
					// 	console.log({a:+click < +cur_click, b: +cur_click > (+click2 || -Infinity)})
					// 	if (!(+cur_click > (+click2 || -Infinity) || +click < +cur_click))
					// 		grandchild.setAttribute("hidden", "");
					// }, 1000);
				};

				child_state_transitions[clicky].push(unhide_slide);
				child_state_transitions[clicky - 1].push(hide_slide);

				if (click2) {
					child_state_transitions[click2]?.push(hide_slide);
					child_state_transitions[click2 - 1].push(unhide_slide);
				}
			}
			current_click_num = recursivelyHandleChildren(child_state_transitions, grandchild, current_click_num);
		}

		return current_click_num;
	}

	function countClicks(child, state) {
		for (const grandchild of child.children) {
			let click = grandchild.getAttribute("click")
			if (click !== null) {
				grandchild.setAttribute("hidden", "");
				const clicky = (click === "") ? ++state.current_click_num : parseInt(click) || 1;
				if (clicky > state.max_click_num) state.max_click_num = clicky;
			}
			countClicks(grandchild, state);
		}
		return state;
	}

	let IS_MOBILE_FULL_SCREEN = false;

	post_processes.push(() => {
		for (const [is_overlay, elements] of  [[false, slide_elements], [true, overlay_elements]]) {
			for (const [i, child] of elements.entries()) {
				child.setAttribute("hidden", "");
				const id = child.getAttribute("id");
				if (id === null) throw new Error("Please add an ID to slide " + i + ` (after the slide with an id of "${elements[i - 1].id}")`);
				const id_without_overlay = id.replace("-overlay", "");
				const click_attr = child.getAttribute("clicks");
				const num_clicks = is_overlay ? clicks.get(id_without_overlay) : parseInt(click_attr?.split(",").length > 1 ? click_attr.split(",").length + 1 : click_attr) ||
					(1 + countClicks(child, { current_click_num: 0, max_click_num: 0 }).max_click_num);

				clicks.set(id_without_overlay, num_clicks);
				const arr = slidesById.get(id_without_overlay) || [];
				arr.push(child);
				slidesById.set(id_without_overlay, arr);

				const child_state_transitions = is_overlay ? state_transitions.get(id_without_overlay) : new Array(num_clicks).fill(0).map(() => []);
				if (!is_overlay) state_transitions.set(id, child_state_transitions);

				child_state_transitions[0].push(() => {
					child.removeAttribute("hidden")
					if (i > 0) elements[i - 1].setAttribute("hidden", "")
					if (i < elements.length - 1) elements[i + 1].setAttribute("hidden", "")
					if (!is_overlay)
						container.setAttribute("viewBox", `0 0 1920 ${pane_heights.get(id) || 1080}`);
				});

				child_state_transitions[num_clicks - 1].push(() => {
					child.removeAttribute("hidden")
					if (i > 0) elements[i - 1].setAttribute("hidden", "")
					if (i < elements.length - 1) elements[i + 1].setAttribute("hidden", "")
				});

				// if (is_overlay)
				// 	state_transitions.get(id_without_overlay).forEach((a, i) => {
				// 		child_state_transitions.forEach((b, j) => {
				// 			console.log(a);
				// 			a.push(b);
				// 		});
				// 	});

				recursivelyHandleChildren(child_state_transitions, child, 0)
			}
		}
	});

				// 	global_scrolls.push({
				// 	section: slide_id,
				// 	slide_num: i + 1,
				// 	animation_duration,
				// 	pos: next,
				// });

	post_processes.push(() => {
		/**
		 * Create a cubic-bezier easing function.
		 * @param {number} p0x
		 * @param {number} p0y
		 * @param {number} p1x
		 * @param {number} p1y
		 */
		function cubicBezier(p0x, p0y, p1x, p1y) {
		// Helper functions for bezier math
		function cubic(a, b, m) { return ((1 - 3*b + 3*a) * m ** 3) + ((3*b - 6*a) * m ** 2) + (3*a * m); }
		function cubicDerivative(a, b, m) { return (3*(1 - 3*b + 3*a) * m ** 2) + (2*(3*b - 6*a) * m) + (3*a); }

		return function(t) {
			// Newton-Raphson iteration to find the parametric value for time t
			let x = t, i = 0;
			for (; i < 5; i++) {
			const xEstimate = cubic(p0x, p1x, x) - t;
			const dx = cubicDerivative(p0x, p1x, x);
			if (Math.abs(xEstimate) < 1e-6) break;
			x -= xEstimate / dx;
			}
			return cubic(p0y, p1y, x);
		};
		}

		// Your easing curve: cubic-bezier(0.69, 0.02, 0.53, 1)
		const easeCustom = cubicBezier(0.69, 0.02, 0.53, 1);

		/**
		 * Smooth scroll to target using cubic-bezier easing.
		 */
		let active_scroll_id = 0;
		function scrollToPosition(targetY, duration = 500) {
			const startY = window.scrollY;
			const distance = targetY - startY;
			let startTime = null;
			const my_scroll_id = ++active_scroll_id;

			function step(timestamp) {
				if (active_scroll_id !== my_scroll_id) return;
				if (!startTime) startTime = timestamp;
				const elapsed = timestamp - startTime;
				const progress = Math.min(elapsed / duration, 1);

				const easedProgress = easeCustom(progress);

				if (elapsed < duration) {
					window.scrollTo(0, startY + distance * easedProgress);
					requestAnimationFrame(step);
				} else {
					window.scrollTo(0, targetY);
				}
			}

			requestAnimationFrame(step);
		}

		let scroll_id = 0;

		function scrollElementOffsetAnimated(elem, offsetPx, duration = 500, section) {
			if (IS_MOBILE_FULL_SCREEN) return;
			let startTime = 0.0;
			const my_scroll_id = ++scroll_id;

			function step(timestamp) {
				if (cur_slide != section) return;
				if (my_scroll_id !== scroll_id) return;
				if (!startTime) startTime = timestamp;
				const elapsed = timestamp - startTime;
				const rect = elem.getBoundingClientRect();
				window.scrollTo(0, window.scrollY + rect.top - offsetPx);
				if (elapsed < duration) requestAnimationFrame(step);
			}

			requestAnimationFrame(step);
		}


		{
			let i = 0;
			const selectors = new Set();
			const sections = new Set();

			const positions = global_scrolls.map(({ pos }) => 120 - pos * 80 - 55);

			for (const [i, { section, slide_num, animation_duration, selector, pos, do_not_move_mobile }] of global_scrolls.entries()) {
				// console.log({ section, slide_num, animation_duration, selector, pos });
				if (do_not_move_mobile) continue;

				// console.log({selector:selector.slice(0, -("-rect".length))});
				sections.add(section);
				selectors.add(selector);

				global_animations.push({
					section,
					selector: selector.slice(0, -("-rect".length)),
					slide_num,
					animation_duration,
					forward_only: true,
					keyframes: {
						0:    {  transform: `translateY(${positions[i - 1] || 0}px)` },
						100:   { transform: `translateY(${positions[i]}px)` },
					},
					mobile_full_screen_only: true,
				});

				global_animations.push({
					section,
					selector: selector.slice(0, -("-rect".length)),
					slide_num,
					animation_duration: global_scrolls[i+1]?.animation_duration,
					backward_only: true,
					keyframes: {
						0:    {  transform: `translateY(${positions[i + 1] || 0}px)` },
						100:   { transform: `translateY(${positions[i]}px)` },
					},
					mobile_full_screen_only: true,
				});

				state_transitions.get(section)[slide_num].push(() => {
					const elem = document.querySelector(selector);
					const styles = getComputedStyle(elem);

					// console.log("selector", selector);
					// console.log("elem", elem);
					// console.log("styles.animationDuration", styles.animationDuration);

					scrollElementOffsetAnimated(document.querySelector(selector),
						// offset from top
						70,
						1000 * styles.animationDuration.slice(0, -1), section);
				});

			}

			const selectors_arr = [...selectors];
			const sections_arr = [...sections];

			for (let i = 0; i < selectors_arr.length; i++)
				state_transitions.get(sections_arr[i])[0].push(() => {
					scrollElementOffsetAnimated(document.querySelector(selectors_arr[i]),
								// offset from top
								70,
								5000, sections_arr[i]);
				});
		}

		// console.log(global_scrolls);
	})

	const code_info = new Map();

	let code_block_i = 0;

	for (const codeblock of document.getElementsByClassName("code")) {
		let codeblock_id = codeblock.getAttribute("id");
		const x = +codeblock.getAttribute("x");
		const y = +codeblock.getAttribute("y");
		const steps = codeblock.getAttribute("steps");
		const do_not_move_mobile = codeblock.hasAttribute("do-not-move-mobile");
		const mini_steps = codeblock.getAttribute("mini-steps");
		const lang = codeblock.getAttribute("lang");
		const width = +codeblock.getAttribute("width");
		const click = +codeblock.getAttribute("click");
		if (codeblock.getAttribute("height")) {
			throw new Error("Height is not allowed on code block")
		}
		const line_height = +codeblock.getAttribute("line-height");
		const font_size = codeblock.getAttribute("font-size") || "";
		const letter_spacing = codeblock.getAttribute("letter-spacing") || "";

		const line_num_indent = +codeblock.getAttribute("line-num-indent");
		const hide_line_numbers = codeblock.hasAttribute("hide-line-numbers");

		const line_indent = +codeblock.getAttribute("line-indent");
		let slide = codeblock;
		do slide = slide.parentNode; while (!slide.classList.contains("slide"));
		const slide_id = slide.getAttribute("id");


		const [lines, ranges] = preprocess(slide_id, codeblock.innerHTML, lang);

		if (codeblock_id) {
			code_info.set(codeblock_id, { x, y, width, line_height, line_num_indent, hide_line_numbers, line_indent, slide, ranges });
		} else {
			codeblock_id = `${slide_id}-codeblock-${code_block_i++}`;
			codeblock.setAttribute("id", codeblock_id);
		}

		if (lines.length > 0) {
			let innerHTML = codeblock.hasAttribute("hide-background") ? '' : `<rect x="${x || 0}" y="${y || 0}" height="${y + (line_height*(codeblock.getAttribute("lines") || lines.length)) + 20}" width="${width}" fill="black"></rect>`;
			innerHTML += lines.map((e, i) => `<text class="line-of-code" line-no="${i-1}" x="${x + line_indent}" y="${y + (line_height*(i+1))}">${e}</text>`).join('\n');

			if (!hide_line_numbers)
				innerHTML += lines.map((_, i) => `<text class="line-number" x="${x + line_num_indent}" y="${y + (line_height*(i+1)) - 1}" text-anchor="end">${i + 1}</text>`);

			const extra_height = y + (line_height*(lines.length));
			const [body] = document.getElementsByTagName("body");
			if (extra_height > 1080) {
				pane_heights.set(slide_id, extra_height);

				body.insertAdjacentHTML("beforeend",
					`
					<style>
					#container[slide="${slide_id}"] {
					height: ${extra_height / 10.80}%
					}
					</style>
				`);
			}

			if (font_size || letter_spacing) {
				body.insertAdjacentHTML("beforeend", `
				<style>
				#${codeblock_id} text.line-of-code {
					${font_size && `font-size: ${font_size};`}
					${letter_spacing && `letter-spacing: ${letter_spacing};`}
				}
				</style>
				`);
			}

			codeblock.innerHTML = innerHTML;
		}


		const colors = ["rgb(0, 100, 0)", "purple", "rgb(130, 0, 0)", "rgb(88, 0, 158)", "rgb(0, 0, 200)"];

		if (mini_steps) {
// <svg width="300" height="120" viewBox="0 0 300 120" xmlns="http://www.w3.org/2000/svg">


//   <!-- visible frame for reference -->
//   <rect x="10" y="10" width="200" height="80" fill="none" stroke="#333"/>

//   <!-- anything inside this group will be clipped to the rect above -->
//   <defs>
//     <clipPath id="boxClip" clipPathUnits="userSpaceOnUse">
//       <!-- rectangle that defines the clipping box -->
//       <rect x="10" y="10" width="200" height="80" rx="8"/>
//     </clipPath>
//   </defs>
//   <g clip-path="url(#boxClip)">
//     <!-- content that extends beyond the rect -->
//     <rect x="0" y="0" width="260" height="120" fill="lightblue"/>
//     <text x="20" y="60" font-size="28">This gets clipped →</text>
//   </g>
// </svg>

			codeblock.innerHTML = `
			<defs>
			  <clipPath id="${codeblock_id}-clipper" clipPathUnits="userSpaceOnUse">
			    <rect x="${x}" y="${y}" width="${1920-x}" height="${1250}"/>
			  </clipPath>
			</defs>
			<g clip-path="url(#${codeblock_id}-clipper)">
			<g id="${codeblock_id}-translator">
			<rect id="${codeblock_id}-box" width="700"></rect>
			${codeblock.innerHTML}
			</g>
			</g>`;

			let last_translation = 0;
			let last_height = 0;
			let last_x = x + 40;
			let last_y = y;

			const mini_step_data = mini_steps.split(',').map((str, i) => {
				let [line, len] = str.split(':');
				len = i && +(len || 1);
				line = +line;

				return {
					prev_y: last_translation,
					y: last_translation = -line_height * Math.max(0, line - 4) - 10,
					prev_height: last_height,
					height: last_height = line_height * len,

					prev_box_y: last_y,
					box_y: last_y = y + line_height * (line + 1) + 10,

					prev_color: colors[(click + i + 4) % colors.length],
					color: colors[(click + i + 5) % colors.length],
				};
			});

			mini_step_data.push({
				prev_y: y,
				y: y,
				prev_height: 0,
				height: 0,

				prev_box_y: y,
				box_y: y,

				prev_color: colors[(click + mini_step_data.length + 0) % colors.length],
				color: colors[(click + mini_step_data.length + 1) % colors.length],
			});

			Array.prototype.push.apply(global_animations, mini_steps.split(',').map((str, i) => {
				let [line, len] = str.split(':');
				len = +len || 0;
				line = +line;

				const current_step = mini_step_data[i];
				const next_step = mini_step_data[i + 1];
				const animation_duration = i !== 0 ? "0.25s" : "2s";

				return [{
					section: slide_id,
					selector: `#${codeblock_id}-translator`,
					slide_num: click + i,
					forward_only: true,
					skip_auto_prev_state: true,
					animation_delay: i ? "0s" : "1s",
					animation_duration: i !== 0 ? "0.25s" : "2s",
					keyframes: {
						0:   { transform: `translateY(${current_step.prev_y}px)` },
						100: { transform: `translateY(${current_step.y}px)` },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-box`,
					slide_num: click + i,
					forward_only: true,
					skip_auto_prev_state: true,
					animation_delay: i ? "0s" : "1s",
					animation_duration: i !== 0 ? "0.25s" : "2s",
					keyframes: {
						0:   { height: `${current_step.prev_height}px`, fill: current_step.prev_color, x: last_x, y: current_step.prev_box_y },
						100: { height: `${current_step.height}px`, fill: current_step.color, x: last_x, y: current_step.box_y },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-translator`,
					slide_num: click + i,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration: "0.25s",
					keyframes: {
						0:   { transform: `translateY(${next_step.y}px)` },
						100: { transform: `translateY(${current_step.y}px)` },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-box`,
					slide_num: click + i,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration: "0.25s",
					keyframes: {
						0:   { height: `${next_step.height}px`, fill: next_step.color, x: last_x, y: next_step.box_y },
						100: { height: `${current_step.height}px`, fill: current_step.color, x: last_x, y: current_step.box_y },
					}
				}];
			}).flat());

		}

		if (steps) {
			codeblock.insertAdjacentHTML("afterbegin", `<rect id="${codeblock_id}-rect" width="1950" fill="purple" style="opacity: 0.6"></rect>`)
			let last = 0;
			let last_height = "0px";
			let last_y = "0px";

			Array.prototype.push.apply(global_animations, steps.split(",").map((av, i, k) => {
				const isLast = k.length === i + 1;
				let [v, num_lines] = av.split(":");
				num_lines ||= '1';
				const prev = last;

				// (8 - num_lines)
				// 2076

				const next = last = Math.min(0, (-v + Math.max(2, 3 - num_lines)) * line_height) - 9;
				let anim_duration = Math.max(0.2, Math.abs(next - prev) / (10000));
				if (anim_duration > 1) {
					anim_duration = 2;
				}
				const animation_duration = `${(i === 0 ? 1/0.9 : 1.25) * anim_duration}s`;
				// console.log({ prev, next, animation_duration });
				// console.log([v, y + (line_height*(v - 1)) + 10]);

				const prev_height = last_height;
				const next_height = last_height = `${line_height*(num_lines || 1) + line_height / 7}px`;

				const prev_y = last_y;
				const next_y_num = y + (line_height*(v - 1)) + line_height / 7;
				const next_y = last_y = `${next_y_num}px`;

				global_scrolls.push({
					section: slide_id,
					slide_num: i + 1,
					animation_duration,
					linear: true,
					pos: +v,
					selector: `#${codeblock_id}-rect`,
					do_not_move_mobile,
				});

				// console.log({codeblock_id,v,animation_duration,prev_height, prev_y, next_height, next_y})


				return [

				// {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i + 1,
				// 	forward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${prev}px)` },
				// 		100: { transform: `translateY(${next}px)` },
				// 	}
				// }, {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i,
				// 	backward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${next}px)` },
				// 		100: { transform: `translateY(${prev}px)` },
				// 	}
				// },
				{
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i + 1,
					forward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: prev_height, y: prev_y, fill: colors[(click + i + 0) % colors.length] },
						90: i === 0 ? { y: next_y, height: 0 } : undefined,
						100: { height: next_height, y: next_y, fill: colors[(i + 1) % colors.length] },
					}
				}, {
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: next_height, y: next_y, fill: colors[(click + i + 1) % colors.length] },
						10: i === 0 ? { height: 0 } : undefined,
						100: { height: prev_height, y: prev_y, fill: colors[(click + i + 0) % colors.length] },
					}
				}, isLast && {
					section: slide_id,
					selector: `#${codeblock_id}-rect`,
					slide_num: i + 1,
					backward_only: true,
					skip_auto_prev_state: true,
					animation_duration,
					keyframes: {
						0:   { height: next_height, y: next_y },
						90: i === 0 ? { y: next_y, height: 0 } : undefined,
						100: { height: next_height, y: next_y },
					}
				},
				// isLast && {
				// 	section: slide_id,
				// 	selector: "#" + codeblock_id,
				// 	slide_num: i + 1,
				// 	backward_only: true,
				// 	skip_auto_prev_state: true,
				// 	animation_duration,
				// 	keyframes: {
				// 		0:   { transform: `translateY(${next}px)` },
				// 		100: { transform: `translateY(${next}px)` },
				// 	}
				// }
			];
			}).flat())
		}
	}

	for (const text of [...document.getElementsByTagName("text")]) {
		const align = text.getAttribute("align");
		if (align) {
			const line = +text.getAttribute("line");
			const info = code_info.get(align);

			text.setAttribute("x", info.x + info.line_indent);
			text.setAttribute("y", info.y + (info.line_height*(line+1)));

			for (const cl of ["label", "small-label", "xsmall-label", "ysmall-label", "big-label"]) {
				const label = text.getAttribute(cl);

				if (label) {
					const click = text.getAttribute("click");
					text.insertAdjacentHTML("beforebegin", `<text id="${text.getAttribute("id")}-label" class="${cl}" ${click ? `click=${click}` : ""} text-anchor="end" x="${info.x + info.line_indent}" y="${info.y + (info.line_height*(line+1))}">${label.replaceAll(">>", "»").replaceAll("<<", "«")}${label.length === 1 ? '' : `:`}&nbsp;</text>`)
				}
			}
		}
	}

	for (const bits of document.getElementsByClassName("bits-auto-color")) {
		bits.innerHTML = bits.innerHTML.replaceAll(/1+/g, e => `<tspan class="bit-1">${e}</tspan>`);
	}

	// const indexToChar = new Array(64).fill('').map((_, i) => i < 62 ? i < 36 ? i.toString(36) : (i - 26).toString(36).toUpperCase() : '&$'[i - 62]);


	for (const bits of document.getElementsByClassName("bits-match-color")) {
		const align = bits.getAttribute("align");
		if (!align) throw new Error("bits-match-color must use the 'align' property to be paired up with something!")
		const info = code_info.get(align);
		// console.log(bits.innerHTML);
		bits.innerHTML = processRanges(info.ranges, bits.innerHTML).join('\n');
	}

	{
		let i = 0;
		for (const bits of document.getElementsByClassName("bits-match-color2")) {
			const align = bits.getAttribute("align");
			if (!align) throw new Error("bits-match-color2 must use the 'align' property to be paired up with something!")
			const info = code_info.get(align);

			const [smally] = bits.getElementsByClassName("bits-small")

			for (const [kind, bottom, top] of info.ranges) {
				if (bottom <= i && i < top) {
					smally.classList.add("code-" + kind);
					break;
				}
			}
			// bits.innerHTML = processRanges(info.ranges, bits.innerHTML).join('\n');
			i++;
		}
	}

	for (const post_process of post_processes) post_process();

	const all_styles = new Map();

{
	let i = 0;
	let styles = new Array();
	let prev_selector;
	let prev_slide_num;
	let prev_section;
	let prev_mobile_full_screen_only;
	const animations = new Array();

	function getSelectorForInternal(ge, num_clicks) {
		if (ge === num_clicks) throw new Error("num_clicks must be higher than the target click (clicks start at 0)")
		let arr = [];
		let y = ge;
		for (; y % 10; y++) {
			if (y >= num_clicks) return arr;
			arr.push(`[click="${y}"]`);
		}

		let z = y;
		let i = -1;
		for (; z % 100; z += 10) {
			if (z >= num_clicks) return arr;
			if (z / 10 === ge) {
				for (; z % 100; z += 10) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 10}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			arr.push(`[click^="${z / 10}"]:not([click="${z / 10}"])`);
		}

		let q = z;
		i = -1;
		for (; z % 1000; z += 100) {
			if (z >= num_clicks) return arr;
			// console.log(z, ge)
			if (z / 100 === ge) {
				for (; z % 1000; z += 100) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 100}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			for (let j = 0; j < 10; j++) {
				const k = z / 10 + j;

				arr.push(`[click^="${k}"]${ge <= k && k < num_clicks ? '' : `:not([click="${k}"])`}`);
			}
		}

		return arr;
	}

	function getSelectorFor(ge, num_clicks) {
		return `:is(${getSelectorForInternal(+ge, +num_clicks).join(", ")})`;
	}

	function getSelectorForRangeInternal(num_clicks, ge, lt) {
		if (ge === num_clicks) throw new Error("num_clicks must be higher than the target click (clicks start at 0)")
		let arr = [];
		let y = ge;
		for (; y % 10; y++) {
			if (y >= num_clicks) return arr;
			arr.push(`[click="${y}"]`);
		}

		let z = y;
		let i = -1;
		for (; z % 100; z += 10) {
			if (z >= num_clicks) return arr;
			if (z / 10 === ge) {
				for (; z % 100; z += 10) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 10}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			arr.push(`[click^="${z / 10}"]:not([click="${z / 10}"])`);
		}

		let q = z;
		i = -1;
		for (; z % 1000; z += 100) {
			if (z >= num_clicks) return arr;
			// console.log(z, ge)
			if (z / 100 === ge) {
				for (; z % 1000; z += 100) {
					if (z >= num_clicks) return arr;
					arr[++i] = `[click^="${z / 100}"]`
				}
				break;
			}
			// console.log(arr.findIndex(v => v === `[click="${z / 10}"]`), `[click="${z / 10}"]`);
			for (let j = 0; j < 10; j++) {
				const k = z / 10 + j;

				arr.push(`[click^="${k}"]${ge <= k && k < num_clicks ? '' : `:not([click="${k}"])`}`);
			}
		}

		return arr;
	}

	function getSelectorForRange(num_clicks, ge, lt) {
		return `:is(${getSelectorForRangeInternal(+num_clicks, +ge, +lt).join(", ")})`;
	}

	// console.log(getSelectorFor('5', '23'));
	// console.log(getSelectorFor('23', '33'));
	// console.log(getSelectorFor('20', '30'));

	const elements_to_selectors = new Map();
	const selectors_to_keyframes = new Map();

	for (const { section = (() => { throw "Invalid section" })(), selector, slide_num, keyframes } of global_animations.filter(e => e)) {
		const start_keyframe = keyframes[0];
		const end_keyframe = keyframes[100];

		for (const [, individual_selector] of selector.matchAll(/([^,]+?)(?:, ?|$)/g)) {
			for (const element of document.querySelectorAll(individual_selector)) {
				const old = elements_to_selectors.get(element);
				if (old && old !== individual_selector) {
					throw new Error("Cannot make an object peacefully coexist in two different classes/ids. Please use id's instead. Conflict between `" + individual_selector + "` and `" + old + "`");
				} else {
					elements_to_selectors.set(element, individual_selector);
				}
			}

			let arr = selectors_to_keyframes.get(individual_selector);
			if (arr === undefined) {
				arr = new Array();
				selectors_to_keyframes.set(individual_selector, arr);
			}
			arr.push({ slide_num, start_keyframe, end_keyframe });
		}
	}

	for (const [i, v] of selectors_to_keyframes.entries()) {
		let prev_slide_num = 0;

		for (const { slide_num, start_keyframe, end_keyframe } of v.sort((a, b) => a.slide_num - b.slide_num)) {
			// prev_slide_num, slide_num, new Array(slide_num - prev_slide_num).fill().map((_, i) => i + prev_slide_num);
			// console.log(slide_num, prev_slide_num);
			prev_slide_num = slide_num;
		}
	}

	//
	for (const { section, selector, slide_num, keyframes, animation_delay = '0s', animation_duration = '0s', skip_auto_prev_state = section === prev_section && selector === prev_selector, forward_only = false, backward_only = false, ease = false, linear = false, continuous = false, mobile_full_screen_only = false } of global_animations.filter(e => e)) {
		if (section !== (prev_section ?? section)) {
			all_styles.set(prev_section, styles.join("\n"));
			styles = [all_styles.get(section) ?? ""] ?? new Array();
		}
		i += 1;
		const old_styles_len = styles.length;
		const keyframe_entries = Object.entries(keyframes).filter(e => e[1] !== undefined).map(([a, b]) => [+a, b]).sort((a, b) => a[0] - b[0]);
		if (keyframe_entries[0]?.[0] !== 0) throw "Missing keyframe 0";
		if (keyframe_entries[keyframe_entries.length - 1]?.[0] !== 100) throw "Missing keyframe 100";

		if (selector !== prev_selector || slide_num !== prev_slide_num || mobile_full_screen_only !== prev_mobile_full_screen_only) {
			animations.length = 0;
		}

		const animation = `animation${i} ${animation_duration} ${linear ? "linear" : ease === true ? "ease" : ease || "cubic-bezier(0.69, 0.02, 0.53, 1)"} ${animation_delay} 1 forwards normal`;
		animations.push(animation)

		const mobile_only = mobile_full_screen_only ? "#container[mobile-translate] " : ""
		let selectors = selector.split(',');

		if (!skip_auto_prev_state) {
			styles.push(`${mobile_only}.slide#${section} ${selector} {
		${Object.entries(keyframe_entries[0][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	}`);
		}


		// if (selector.startsWith('.')) {
		// 	Array.prototype.push.apply(selectors, [...document.querySelectorAll(selector)].filter(x => x.id).map(x => `${selector}#${x.id}`));
		// }

		styles.push(`${selectors.map(selector => `${mobile_only}.slide#${section}[${continuous ? 'fragment-' : 'click="'}${slide_num}${continuous ? '' : '"'}]${forward_only ? "[present-went-forward]" : backward_only ? "[present-went-backward]" : ""} ${selector}`).join(',\n')} {
		animation: ${animations.join(",\n\t")};
	}`);

		if (!continuous) styles.push(`${selectors.map(selector => `${mobile_only}.slide#${section}[fragment-${slide_num + 1}] ${selector}`).join(',\n')} {
		${Object.entries(keyframe_entries[keyframe_entries.length - 1][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	}`);

	// 	if (forward_only) styles.push(`${`${selectors.map(selector => `.slide#${section}[click="${slide_num}"][present-went-backward] ${selector}`).join(',\n')} {
	// 	${Object.entries(keyframe_entries[keyframe_entries.length - 1][1]).map(([a, b]) => `${a}: ${b};`).join("\n\t")}
	// }`}`);

		styles.push(`@keyframes animation${i} {
		${keyframe_entries.map(([a, b]) => `${a}% { ${Object.entries(b).map(([a, b]) => `${a}: ${b};`).join(" ")} }`).join("\n\t")}
	}`);

		if (mobile_full_screen_only) {
			// for (let n = old_styles_len; n < styles.length; n++)
				// console.log(styles[n]);
			// console.log(styles[styles.length - 1]);
		}

		prev_selector = selector;
		prev_slide_num = slide_num;
		prev_section = section;
		prev_mobile_full_screen_only = mobile_full_screen_only;
	}

	all_styles.set(prev_section, styles.join("\n"));

	var styleSheet = document.createElement("style");
	styleSheet.id = "slide-animations";
	styleSheet.innerHTML = [...all_styles.values()].join('\n');
	document.head.appendChild(styleSheet);
}

	const getStateFromURL = () => {
		const slide_arg = window.location.href.split("#").pop();
		const [slide_title, clicks_amt] = slide_arg.split("?");
		let cur_slide = slide_title || slide_elements[0].id;
		if (!clicks.has(cur_slide)) [[cur_slide]] = clicks;

		return [
			cur_slide,
			(clicks_amt || "").startsWith("click=")
			? Math.min(clicks.get(cur_slide) - 1, parseInt(clicks_amt.slice("click=".length)) || 0)
			: 0
		];
	}

	let [cur_slide, cur_click] = getStateFromURL();

	const updateURL = () => window.location.href = "#" + cur_slide + (cur_click === 0 ? '' : `?click=${cur_click}`);

	const updateContainerSlideAttribute = () => {
		container.setAttribute("slide", cur_slide);
		overlay.setAttribute("slide", cur_slide + "-overlay");
	}


	// window.onhashchange = function() {
	// 	const targetState = getSlideFromURL();
	// 	setState(targetState)
	// };

	function applyTransitions() {
		for (const cur_slide_element of slidesById.get(cur_slide)) {
			cur_slide_element.setAttribute("click", "" + cur_click);
			for (let i = 0; i <= cur_click; i++) cur_slide_element.setAttribute(`fragment-${i}`, "");
			const max_clicks = clicks.get(cur_slide);
			for (let i = cur_click; ++i < max_clicks; ) cur_slide_element.removeAttribute(`fragment-${i}`);
		}

		for (const state_transition of state_transitions.get(cur_slide)[cur_click]) {
			state_transition();
		}
	}

	function applyStateTransitionsUpToCurrentClickInSlide() {
		for (let i = 0; i <= cur_click; i++) {
			for (const state_transition of state_transitions.get(cur_slide)[i]) {
				state_transition();
			}
		}
	}

	function nextSlide() {
		let next_slide;
		let wasPreviousCurrentSlide = false;
		for (const [slide] of clicks) {
			if (wasPreviousCurrentSlide) {
				next_slide = slide;
				break;
			}
			wasPreviousCurrentSlide = cur_slide === slide;
		}
		if (!next_slide) return false;
		for (const cur_slide_element of slidesById.get(cur_slide)) {
			for (let i = 0; i < cur_click; i++) {
				cur_slide_element.removeAttribute(`fragment-${i}`);
			}
			cur_slide_element.removeAttribute("click");
			cur_click = 0;
		}

		cur_slide = next_slide;
		updateContainerSlideAttribute();
		return true;
	}

	function goForward() {
		const old_slide = cur_slide;
		const max_click = clicks.get(cur_slide) - 1;
		cur_click++;
		let is_new_slide = true;
		if (cur_click > max_click) {
			is_new_slide = nextSlide();
			if (!is_new_slide)
				cur_click--;
		}
		for (const old_slide_element of slidesById.get(old_slide)) {
			old_slide_element.removeAttribute("present-went-backward");
			if (old_slide !== cur_slide) old_slide_element.removeAttribute("present-went-forward");
		}
		for (const cur_slide_element of slidesById.get(cur_slide)) cur_slide_element.setAttribute("present-went-forward", "");
		if (is_new_slide) {
			applyTransitions();
			updateURL();
		}
	}

	function prevSlide() {
		for (const slide of slidesById.get(cur_slide)) {
			slide.removeAttribute("click");
			slide.removeAttribute("fragment-0");
		}
		let [[previous_slide]] = clicks
		for (const [slide] of clicks) {
			if (cur_slide === slide) break;
			previous_slide = slide;
		}
		cur_slide = previous_slide;
		cur_click = clicks.get(cur_slide) - 1;
		applyStateTransitionsUpToCurrentClickInSlide();
		updateContainerSlideAttribute();
	}

	function goBackward() {
		const old_slide = cur_slide;

		if (cur_click === 0) {
			prevSlide();
		} else {
			cur_click--;
		}

		for (const old_slide_element of slidesById.get(old_slide)) {
			old_slide_element.removeAttribute("present-went-forward");
			if (old_slide !== cur_slide) old_slide_element.removeAttribute("present-went-backward");
		}
		for (const slide of slidesById.get(cur_slide)) slide.setAttribute("present-went-backward", "");

		applyTransitions();
		updateURL();
	}

	let is_control_depressed = false;

	window.addEventListener("touchend", () => {
		document.body.requestFullscreen({ navigationUI: "hide" })
		.then(() => {
			IS_MOBILE_FULL_SCREEN = true;
			container.setAttribute("mobile-translate", "");
		})
		.catch(err => {
			console.error("Fullscreen request failed:", err);
		});
	});
	// window.addEventListener("touchstart", () => void (document.querySelector("body").requestFullscreen({ navigationUI: "hide" })));
	window.addEventListener("keyup", function (event) {
		// Do nothing if the event was already processed
		if (event.defaultPrevented) return;
		switch (event.key) {
		case "Control":
			is_control_depressed = false;
			break;
		default:
			return; // Quit when this doesn't handle the key event.
		}
	});

	window.addEventListener("keydown", function (event) {
		// Do nothing if the event was already processed
		if (event.defaultPrevented) return;

		switch (event.key) {
		case "ArrowLeft":
			goBackward();
			break;
		case "ArrowRight":
			goForward();
			break;
		case "Control":
			is_control_depressed = true;
			break;
		case 'c':
			if (is_control_depressed) {
				navigator.clipboard.writeText(code_snippets.get(cur_slide));
			}
		default:
			return; // Quit when this doesn't handle the key event.
		}

		// Cancel the default action to avoid it being handled twice
		event.preventDefault();
	}, true);

	applyTransitions();
	updateURL();
	applyStateTransitionsUpToCurrentClickInSlide();
	updateContainerSlideAttribute();
	for (const slide of slidesById.get(cur_slide)) slide.setAttribute("present-went-forward", "");
</script>


<script>
function subtractBinary(a, b) {
    // Convert binary strings to integers
    const intA = BigInt(`0b${[...a.replaceAll('.', '0')].reverse().join('')}`);
    const intB = BigInt(`0b${[...b.replaceAll('.', '0')].reverse().join('')}`);

    // Subtract
    let result = intA - intB;
	const flip_around = result < 0n;

    // If negative, handle appropriately
    if (flip_around) {
        result = ~result;
    }

	let str = result.toString(2).padStart(64, '0');

	if (flip_around) {
        str = str.replaceAll(/[01]/g, e => ['1', '0'][+e]);
    }

    // Convert back to binary string
    return [...str.replaceAll('0', '.')].reverse().join('');
}

function opBinary(a, b, op) {
    // Convert binary strings to integers
    const intA = BigInt(`0b${[...a.replaceAll('.', '0')].reverse().join('')}`);
    const intB = BigInt(`0b${[...b.replaceAll('.', '0')].reverse().join('')}`);

    // Subtract

    let result = undefined;

	switch (op) {
		case '-': result = intA - intB; break;
		case '^': result = intA ^ intB; break;
		case '&': result = intA & intB; break;
		case '&~': result = intA & ~intB; break;
		case '|': result = intA | intB; break;
	}

	const flip_around = result < 0n;

    // If negative, handle appropriately
    if (flip_around) {
        result = ~result;
    }

	let str = result.toString(2).padStart(64, '0');

	if (flip_around) {
        str = str.replaceAll(/[01]/g, e => ['1', '0'][+e]);
    }

    // Convert back to binary string
    return [...str.replaceAll('0', '.')].reverse().join('');
}

// Example:
const even_series = opBinary(
	"0111.111.1..1111.1.11111.11111.111111111.11111.1111.1111111111.1",
	"11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11", '-');

const esc_and_term = opBinary(even_series, '.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1', '^');
const escaped = opBinary(esc_and_term, "11..111....111....1111...1111..111.1111.11111.1111.1111111.11.11", "^");
// console.log(even_series);
// console.log(esc_and_term);
// console.log(escaped);

// console.log(opBinary(
// 	"1....1.....1...11...1.1..1.......11............11............1..",
// 	"1...............1.................1..............1..............", "-"));

// const starts_and_quote_bounds = opBinary("...............1.................1..............1...............", opBinary("1..........1....1.....1........................1................", opBinary("...............1.................1..............1...............",
// opBinary("1...............1.................1..........................1.." & "1..........1....1.....1........................1................", "&"), '-'), '&'), '|');

const starts = "1...............1.................1..........................1..";
const quote_bounds_incl_carry = "1..........1....1.....1........................1................";
const starts_and_quote_bounds = opBinary(starts, quote_bounds_incl_carry, '&');
const carriages_or_newlines_or_eof = "...............1.................1..............1...............";
const subbed = opBinary(carriages_or_newlines_or_eof, starts_and_quote_bounds, '-');
const imm = opBinary(quote_bounds_incl_carry, subbed, '&');
let imm2 = opBinary(carriages_or_newlines_or_eof, imm, '|');
imm2 = opBinary(imm2, starts, '&~');

const cur_ends = opBinary(imm2, opBinary(imm2, starts, '-'), '&~');


// console.log({cur_ends});

</script>

<style>
	.bits-small {
		font-size: 25px;
		letter-spacing: -2px;
		text-align: center;
	}
</style>

</body>
</html>
